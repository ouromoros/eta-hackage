From 8d70d4bf1085391b8bc3dbfba00a9805227dcc3c Mon Sep 17 00:00:00 2001
From: monser <ouromoros@gmail.com>
Date: Tue, 24 Jul 2018 14:24:28 +0800
Subject: [PATCH] Patched

---
 Network.hs                                    |  49 +-
 Network/{BSD.hsc => BSD.hs}                   | 242 +-----
 Network/{Socket.hsc => Socket.hs}             | 692 +++++++-----------
 .../Socket/{ByteString.hsc => ByteString.hs}  |  75 --
 Network/Socket/ByteString/Internal.hs         |  21 -
 Network/Socket/ByteString/Lazy.hs             |   4 -
 Network/Socket/{Internal.hsc => Internal.hs}  |  20 +-
 Network/Socket/{Types.hsc => Types.hs}        | 386 ++++------
 include/HsNet.h                               | 359 ++++-----
 include/HsNetworkConfig.h                     | 178 -----
 java/Utils.java                               | 193 +++++
 network.cabal                                 |  26 +-
 12 files changed, 830 insertions(+), 1415 deletions(-)
 rename Network/{BSD.hsc => BSD.hs} (56%)
 rename Network/{Socket.hsc => Socket.hs} (71%)
 rename Network/Socket/{ByteString.hsc => ByteString.hs} (77%)
 rename Network/Socket/{Internal.hsc => Internal.hs} (95%)
 rename Network/Socket/{Types.hsc => Types.hs} (73%)
 delete mode 100644 include/HsNetworkConfig.h
 create mode 100644 java/Utils.java

diff --git a/Network.hs b/Network.hs
index 8fb8d92..38006df 100644
--- a/Network.hs
+++ b/Network.hs
@@ -17,7 +17,7 @@
 --
 -----------------------------------------------------------------------------
 
-#include "HsNetworkConfig.h"
+#include "HsNet.h"
 
 #ifdef HAVE_GETADDRINFO
 -- Use IPv6-capable function definitions if the OS supports it.
@@ -61,13 +61,14 @@ module Network
 
 import Control.Monad (liftM)
 import Data.Maybe (fromJust)
-import Network.BSD
 import Network.Socket hiding (accept, socketPort, recvFrom,
-                              sendTo, PortNumber, sClose)
-import qualified Network.Socket as Socket (accept)
+                              sendTo, sClose)
+import qualified Network.Socket as Socket
+import qualified Network.Socket.Types as Socket
 import System.IO
 import Prelude
 import qualified Control.Exception as Exception
+import Data.Word(Word32)
 
 -- ---------------------------------------------------------------------------
 -- High Level ``Setup'' functions
@@ -104,9 +105,9 @@ connectTo hostname (PortNumber port) = connect' "Network.connectTo" hostname (sh
 -- IPv4 only.
 
 connectTo hostname (Service serv) = do
-    proto <- getProtocolNumber "tcp"
+    -- proto <- getProtocolNumber "tcp"
     bracketOnError
-        (socket AF_INET Stream proto)
+        (socket AF_INET Stream 6)
         (sClose)  -- only done if there's an error
         (\sock -> do
           port  <- getServicePortNumber serv
@@ -142,9 +143,9 @@ connectTo _ (UnixSocket path) = do
 connect' :: String -> HostName -> ServiceName -> IO Handle
 
 connect' caller host serv = do
-    proto <- getProtocolNumber "tcp"
+    -- proto <- getProtocolNumber "tcp"
     let hints = defaultHints { addrFlags = [AI_ADDRCONFIG]
-                             , addrProtocol = proto
+                             , addrProtocol = 6
                              , addrSocketType = Stream }
     addrs <- getAddrInfo (Just hints) (Just host) (Just serv)
     firstSuccessful caller $ map tryToConnect addrs
@@ -230,13 +231,13 @@ listenOn (UnixSocket path) =
 listen' :: ServiceName -> IO Socket
 
 listen' serv = do
-    proto <- getProtocolNumber "tcp"
+    -- proto <- getProtocolNumber "tcp"
     -- We should probably specify addrFamily = AF_INET6 and the filter
     -- code below should be removed. AI_ADDRCONFIG is probably not
     -- necessary. But this code is well-tested. So, let's keep it.
     let hints = defaultHints { addrFlags = [AI_ADDRCONFIG, AI_PASSIVE]
-                             , addrSocketType = Stream
-                             , addrProtocol = proto }
+                             , addrSocketType = ServerSocket Stream
+                             , addrProtocol = 6 }
     addrs <- getAddrInfo (Just hints) Nothing (Just serv)
     -- Choose an IPv6 socket if exists.  This ensures the socket can
     -- handle both IPv4 and IPv6 if v6only is false.
@@ -274,10 +275,7 @@ accept :: Socket                -- ^ Listening Socket
 accept sock@(MkSocket _ AF_INET _ _ _) = do
  ~(sock', (SockAddrInet port haddr)) <- Socket.accept sock
  peer <- catchIO
-          (do
-             (HostEntry peer _ _ _) <- getHostByAddr AF_INET haddr
-             return peer
-          )
+          (getHostByAddr haddr)
           (\_e -> inet_ntoa haddr)
                 -- if getHostByName fails, we fall back to the IP address
  handle <- socketToHandle sock' ReadWriteMode
@@ -350,9 +348,9 @@ recvFrom :: HostName    -- Hostname
 
 #if defined(IPV6_SOCKET_SUPPORT)
 recvFrom host port = do
-    proto <- getProtocolNumber "tcp"
+    -- proto <- getProtocolNumber "tcp"
     let hints = defaultHints { addrFlags = [AI_ADDRCONFIG]
-                             , addrProtocol = proto
+                             , addrProtocol = 6
                              , addrSocketType = Stream }
     allowed <- map addrAddress `liftM` getAddrInfo (Just hints) (Just host)
                                                    Nothing
@@ -373,14 +371,14 @@ recvFrom host port = do
     _ `oneOf` _ = False
 #else
 recvFrom host port = do
- ip  <- getHostByName host
- let ipHs = hostAddresses ip
+ ip  <- getHostsByName host
+ let ipHs = fromJava ip
  s   <- listenOn port
  let
   waiting = do
      ~(s', SockAddrInet _ haddr)  <-  Socket.accept s
-     he <- getHostByAddr AF_INET haddr
-     if not (any (`elem` ipHs) (hostAddresses he))
+     addresses <- getHostsByAddr haddr
+     if not (any (`elem` ipHs) addresses)
       then do
          sClose s'
          waiting
@@ -476,3 +474,12 @@ firstSuccessful caller = go Nothing
   -- All operations failed, throw error if one exists
   go Nothing  [] = ioError $ userError $ caller ++ ": firstSuccessful: empty list"
   go (Just e) [] = Exception.throwIO e
+
+foreign import java unsafe "@static eta.network.Utils.getHostByAddr"
+  getHostByAddr :: Word32 -> IO String
+
+-- foreign import java unsafe "@static java.net.InetAddess.getAllByName"
+--   getHostsByName :: String -> IO Socket.InetAddressArray
+
+-- foreign import java unsafe "@static eta.network.Utils.getHostsByAddr"
+--   getHostsByAddr :: Word32 -> IO Socket.InetAddressArray
diff --git a/Network/BSD.hsc b/Network/BSD.hs
similarity index 56%
rename from Network/BSD.hsc
rename to Network/BSD.hs
index 8d38dab..5b78bd8 100644
--- a/Network/BSD.hsc
+++ b/Network/BSD.hs
@@ -144,82 +144,29 @@ data ServiceEntry  =
      serviceProtocol :: ProtocolName    -- Protocol
   } deriving (Show, Typeable)
 
-instance Storable ServiceEntry where
-   sizeOf    _ = #const sizeof(struct servent)
-   alignment _ = alignment (undefined :: CInt) -- ???
-
-   peek p = do
-        s_name    <- (#peek struct servent, s_name) p >>= peekCString
-        s_aliases <- (#peek struct servent, s_aliases) p
-                           >>= peekArray0 nullPtr
-                           >>= mapM peekCString
-        s_port    <- (#peek struct servent, s_port) p
-        s_proto   <- (#peek struct servent, s_proto) p >>= peekCString
-        return (ServiceEntry {
-                        serviceName     = s_name,
-                        serviceAliases  = s_aliases,
-#if defined(HAVE_WINSOCK2_H)
-                        servicePort     = (fromIntegral (s_port :: CShort)),
-#else
-                           -- s_port is already in network byte order, but it
-                           -- might be the wrong size.
-                        servicePort     = (fromIntegral (s_port :: CInt)),
-#endif
-                        serviceProtocol = s_proto
-                })
-
-   poke = throwUnsupportedOperationPoke "ServiceEntry"
-
-
 -- | Get service by name.
 getServiceByName :: ServiceName         -- Service Name
                  -> ProtocolName        -- Protocol Name
                  -> IO ServiceEntry     -- Service Entry
-getServiceByName name proto = withLock $ do
- withCString name  $ \ cstr_name  -> do
- withCString proto $ \ cstr_proto -> do
- throwNoSuchThingIfNull "Network.BSD.getServiceByName" "no such service entry"
-   $ c_getservbyname cstr_name cstr_proto
- >>= peek
-
-foreign import CALLCONV unsafe "getservbyname"
-  c_getservbyname :: CString -> CString -> IO (Ptr ServiceEntry)
+getServiceByName name proto = error "getServiceByName: Not implemented yet."
 
 -- | Get the service given a 'PortNumber' and 'ProtocolName'.
 getServiceByPort :: PortNumber -> ProtocolName -> IO ServiceEntry
-getServiceByPort port proto = withLock $ do
- withCString proto $ \ cstr_proto -> do
- throwNoSuchThingIfNull "Network.BSD.getServiceByPort" "no such service entry"
-   $ c_getservbyport (fromIntegral port) cstr_proto
- >>= peek
-
-foreign import CALLCONV unsafe "getservbyport"
-  c_getservbyport :: CInt -> CString -> IO (Ptr ServiceEntry)
+getServiceByPort port proto = error "getServiceByPort: Not implemented yet."
 
 -- | Get the 'PortNumber' corresponding to the 'ServiceName'.
 getServicePortNumber :: ServiceName -> IO PortNumber
-getServicePortNumber name = do
-    (ServiceEntry _ _ port _) <- getServiceByName name "tcp"
-    return port
+getServicePortNumber name = error "getServiceByPort: Not implemented yet."
 
 #if !defined(mingw32_HOST_OS)
 getServiceEntry :: IO ServiceEntry
-getServiceEntry = withLock $ do
- throwNoSuchThingIfNull "Network.BSD.getServiceEntry" "no such service entry"
-   $ c_getservent
- >>= peek
-
-foreign import ccall unsafe "getservent" c_getservent :: IO (Ptr ServiceEntry)
+getServiceEntry = error "getServiceEntry: Not implemented yet."
 
 setServiceEntry :: Bool -> IO ()
-setServiceEntry flg = withLock $ c_setservent (fromBool flg)
-
-foreign import ccall unsafe  "setservent" c_setservent :: CInt -> IO ()
+setServiceEntry flg = error "setServiceEntry: Not implemented yet."
 
 endServiceEntry :: IO ()
-endServiceEntry = withLock $ c_endservent
-
-foreign import ccall unsafe  "endservent" c_endservent :: IO ()
+endServiceEntry = error "endServiceEntry: Not implemented yet."
 
 getServiceEntries :: Bool -> IO [ServiceEntry]
 getServiceEntries stayOpen = do
@@ -246,77 +193,27 @@ data ProtocolEntry =
      protoNumber  :: ProtocolNumber     -- Protocol Number
   } deriving (Read, Show, Typeable)
 
-instance Storable ProtocolEntry where
-   sizeOf    _ = #const sizeof(struct protoent)
-   alignment _ = alignment (undefined :: CInt) -- ???
-
-   peek p = do
-        p_name    <- (#peek struct protoent, p_name) p >>= peekCString
-        p_aliases <- (#peek struct protoent, p_aliases) p
-                           >>= peekArray0 nullPtr
-                           >>= mapM peekCString
-#if defined(HAVE_WINSOCK2_H)
-         -- With WinSock, the protocol number is only a short;
-         -- hoist it in as such, but represent it on the Haskell side
-         -- as a CInt.
-        p_proto_short  <- (#peek struct protoent, p_proto) p
-        let p_proto = fromIntegral (p_proto_short :: CShort)
-#else
-        p_proto        <- (#peek struct protoent, p_proto) p
-#endif
-        return (ProtocolEntry {
-                        protoName    = p_name,
-                        protoAliases = p_aliases,
-                        protoNumber  = p_proto
-                })
-
-   poke = throwUnsupportedOperationPoke "ProtocolEntry"
-
-
 getProtocolByName :: ProtocolName -> IO ProtocolEntry
-getProtocolByName name = withLock $ do
- withCString name $ \ name_cstr -> do
- throwNoSuchThingIfNull "Network.BSD.getProtocolByName" ("no such protocol name: " ++ name)
-   $ c_getprotobyname name_cstr
- >>= peek
-
-foreign import  CALLCONV unsafe  "getprotobyname"
-   c_getprotobyname :: CString -> IO (Ptr ProtocolEntry)
-
+getProtocolByName name = error "getProtocolByName: Not implemented yet."
 
 getProtocolByNumber :: ProtocolNumber -> IO ProtocolEntry
-getProtocolByNumber num = withLock $ do
- throwNoSuchThingIfNull "Network.BSD.getProtocolByNumber" ("no such protocol number: " ++ show num)
-   $ c_getprotobynumber (fromIntegral num)
- >>= peek
-
-foreign import CALLCONV unsafe  "getprotobynumber"
-   c_getprotobynumber :: CInt -> IO (Ptr ProtocolEntry)
-
+getProtocolByNumber num = error "getProtocolByNumber: Not implemented yet."
 
+-- TODO: The protocol number is currently unusued so this
+--       should be OK.
 getProtocolNumber :: ProtocolName -> IO ProtocolNumber
-getProtocolNumber proto = do
- (ProtocolEntry _ _ num) <- getProtocolByName proto
- return num
+getProtocolNumber "tcp" = return 6
+getProtocolNumber _ = error "getProtocolNumber: Not implemented yet for non-tcp protocols."
 
 #if !defined(mingw32_HOST_OS)
 getProtocolEntry :: IO ProtocolEntry    -- Next Protocol Entry from DB
-getProtocolEntry = withLock $ do
- ent <- throwNoSuchThingIfNull "Network.BSD.getProtocolEntry" "no such protocol entry"
-                $ c_getprotoent
- peek ent
-
-foreign import ccall unsafe  "getprotoent" c_getprotoent :: IO (Ptr ProtocolEntry)
+getProtocolEntry = error "getProtocolEntry: Not implemented yet."
 
 setProtocolEntry :: Bool -> IO ()       -- Keep DB Open ?
-setProtocolEntry flg = withLock $ c_setprotoent (fromBool flg)
-
-foreign import ccall unsafe "setprotoent" c_setprotoent :: CInt -> IO ()
+setProtocolEntry flg = error "setProtocolEntry: Not implemented yet."
 
 endProtocolEntry :: IO ()
-endProtocolEntry = withLock $ c_endprotoent
-
-foreign import ccall unsafe "endprotoent" c_endprotoent :: IO ()
+endProtocolEntry = error "endProtocolEntry: Not implemented yet."
 
 getProtocolEntries :: Bool -> IO [ProtocolEntry]
 getProtocolEntries stayOpen = withLock $ do
@@ -335,34 +232,6 @@ data HostEntry =
      hostAddresses :: [HostAddress]     -- Set of Network Addresses  (in network byte order)
   } deriving (Read, Show, Typeable)
 
-instance Storable HostEntry where
-   sizeOf    _ = #const sizeof(struct hostent)
-   alignment _ = alignment (undefined :: CInt) -- ???
-
-   peek p = do
-        h_name       <- (#peek struct hostent, h_name) p >>= peekCString
-        h_aliases    <- (#peek struct hostent, h_aliases) p
-                                >>= peekArray0 nullPtr
-                                >>= mapM peekCString
-        h_addrtype   <- (#peek struct hostent, h_addrtype) p
-        -- h_length       <- (#peek struct hostent, h_length) p
-        h_addr_list  <- (#peek struct hostent, h_addr_list) p
-                                >>= peekArray0 nullPtr
-                                >>= mapM peek
-        return (HostEntry {
-                        hostName       = h_name,
-                        hostAliases    = h_aliases,
-#if defined(HAVE_WINSOCK2_H)
-                        hostFamily     = unpackFamily (fromIntegral (h_addrtype :: CShort)),
-#else
-                        hostFamily     = unpackFamily h_addrtype,
-#endif
-                        hostAddresses  = h_addr_list
-                })
-
-   poke = throwUnsupportedOperationPoke "HostEntry"
-
-
 -- convenience function:
 hostAddress :: HostEntry -> HostAddress
 hostAddress (HostEntry nm _ _ ls) =
@@ -375,28 +244,13 @@ hostAddress (HostEntry nm _ _ ls) =
 
 -- | Resolve a 'HostName' to IPv4 address.
 getHostByName :: HostName -> IO HostEntry
-getHostByName name = withLock $ do
-  withCString name $ \ name_cstr -> do
-   ent <- throwNoSuchThingIfNull "Network.BSD.getHostByName" "no such host entry"
-                $ c_gethostbyname name_cstr
-   peek ent
-
-foreign import CALLCONV safe "gethostbyname"
-   c_gethostbyname :: CString -> IO (Ptr HostEntry)
-
+getHostByName name = error "getHostByName: Not implemented yet."
 
 -- The locking of gethostbyaddr is similar to gethostbyname.
 -- | Get a 'HostEntry' corresponding to the given address and family.
 -- Note that only IPv4 is currently supported.
 getHostByAddr :: Family -> HostAddress -> IO HostEntry
-getHostByAddr family addr = do
- with addr $ \ ptr_addr -> withLock $ do
- throwNoSuchThingIfNull "Network.BSD.getHostByAddr" "no such host entry"
-   $ c_gethostbyaddr ptr_addr (fromIntegral (sizeOf addr)) (packFamily family)
- >>= peek
-
-foreign import CALLCONV safe "gethostbyaddr"
-   c_gethostbyaddr :: Ptr HostAddress -> CInt -> CInt -> IO (Ptr HostEntry)
+getHostByAddr family addr = error "getHostByAddr: Not implemented yet."
 
 #if defined(HAVE_GETHOSTENT) && !defined(mingw32_HOST_OS)
 getHostEntry :: IO HostEntry
@@ -442,69 +296,26 @@ data NetworkEntry =
      networkAddress     :: NetworkAddr
    } deriving (Read, Show, Typeable)
 
-instance Storable NetworkEntry where
-   sizeOf    _ = #const sizeof(struct hostent)
-   alignment _ = alignment (undefined :: CInt) -- ???
-
-   peek p = do
-        n_name         <- (#peek struct netent, n_name) p >>= peekCString
-        n_aliases      <- (#peek struct netent, n_aliases) p
-                                >>= peekArray0 nullPtr
-                                >>= mapM peekCString
-        n_addrtype     <- (#peek struct netent, n_addrtype) p
-        n_net          <- (#peek struct netent, n_net) p
-        return (NetworkEntry {
-                        networkName      = n_name,
-                        networkAliases   = n_aliases,
-                        networkFamily    = unpackFamily (fromIntegral
-                                                        (n_addrtype :: CInt)),
-                        networkAddress   = n_net
-                })
-
-   poke = throwUnsupportedOperationPoke "NetworkEntry"
-
 
 #if !defined(mingw32_HOST_OS)
 getNetworkByName :: NetworkName -> IO NetworkEntry
-getNetworkByName name = withLock $ do
- withCString name $ \ name_cstr -> do
-  throwNoSuchThingIfNull "Network.BSD.getNetworkByName" "no such network entry"
-    $ c_getnetbyname name_cstr
-  >>= peek
-
-foreign import ccall unsafe "getnetbyname"
-   c_getnetbyname  :: CString -> IO (Ptr NetworkEntry)
+getNetworkByName name = error "getNetworkByName: Not implemented yet."
 
 getNetworkByAddr :: NetworkAddr -> Family -> IO NetworkEntry
-getNetworkByAddr addr family = withLock $ do
- throwNoSuchThingIfNull "Network.BSD.getNetworkByAddr" "no such network entry"
-   $ c_getnetbyaddr addr (packFamily family)
- >>= peek
-
-foreign import ccall unsafe "getnetbyaddr"
-   c_getnetbyaddr  :: NetworkAddr -> CInt -> IO (Ptr NetworkEntry)
+getNetworkByAddr addr family = error "getNetworkByAddr: Not implemented yet."
 
 getNetworkEntry :: IO NetworkEntry
-getNetworkEntry = withLock $ do
- throwNoSuchThingIfNull "Network.BSD.getNetworkEntry" "no more network entries"
-          $ c_getnetent
- >>= peek
-
-foreign import ccall unsafe "getnetent" c_getnetent :: IO (Ptr NetworkEntry)
+getNetworkEntry = error "getNetworkByEntry: Not implemented yet."
 
 -- | Open the network name database. The parameter specifies
 -- whether a connection is maintained open between various
 -- networkEntry calls
 setNetworkEntry :: Bool -> IO ()
-setNetworkEntry flg = withLock $ c_setnetent (fromBool flg)
-
-foreign import ccall unsafe "setnetent" c_setnetent :: CInt -> IO ()
+setNetworkEntry flg = error "setNetworkEntry: Not implemented yet."
 
 -- | Close the connection to the network name database.
 endNetworkEntry :: IO ()
-endNetworkEntry = withLock $ c_endnetent
-
-foreign import ccall unsafe "endnetent" c_endnetent :: IO ()
+endNetworkEntry = error "endNetworkEntry: Not implemented yet."
 
 -- | Get the list of network entries.
 getNetworkEntries :: Bool -> IO [NetworkEntry]
@@ -547,14 +358,7 @@ withLock act = withMVar lock (\_ -> act)
 -- processor, as set at boot time.
 
 getHostName :: IO HostName
-getHostName = do
-  let size = 256
-  allocaArray0 size $ \ cstr -> do
-    throwSocketErrorIfMinus1_ "Network.BSD.getHostName" $ c_gethostname cstr (fromIntegral size)
-    peekCString cstr
-
-foreign import CALLCONV unsafe "gethostname"
-   c_gethostname :: CString -> CSize -> IO CInt
+getHostName = error "getHostName: Not implemented yet."
 
 -- Helper function used by the exported functions that provides a
 -- Haskellised view of the enumerator functions:
diff --git a/Network/Socket.hsc b/Network/Socket.hs
similarity index 71%
rename from Network/Socket.hsc
rename to Network/Socket.hs
index 6a1ce6a..01bed0d 100644
--- a/Network/Socket.hsc
+++ b/Network/Socket.hs
@@ -1,4 +1,4 @@
-{-# LANGUAGE CPP, ScopedTypeVariables #-}
+{-# LANGUAGE CPP, ScopedTypeVariables, MultiWayIf #-}
 {-# OPTIONS_GHC -fno-warn-orphans #-}
 -----------------------------------------------------------------------------
 -- |
@@ -45,8 +45,8 @@ module Network.Socket
     , FlowInfo
     , ScopeID
 #endif
-    , htonl
-    , ntohl
+    -- , htonl
+    -- , ntohl
     , ShutdownCmd(..)
     , ProtocolNumber
     , defaultProtocol
@@ -204,10 +204,10 @@ import Control.Concurrent.MVar
 import Data.Typeable
 import System.IO.Error
 
-import GHC.Conc (threadWaitRead, threadWaitWrite)
-##if MIN_VERSION_base(4,3,1)
+import GHC.Conc (threadWaitRead, threadWaitWrite, threadWaitConnect, threadWaitAccept)
+#if MIN_VERSION_base(4,3,1)
 import GHC.Conc (closeFdWith)
-##endif
+#endif
 # if defined(mingw32_HOST_OS)
 import qualified Control.Exception as E
 import GHC.Conc (asyncDoProc)
@@ -222,6 +222,15 @@ import GHC.IO.Handle.FD
 import GHC.IO.Exception
 import GHC.IO
 import qualified System.Posix.Internals
+#if ((ETA_VERSION == 9) && (ETA_BUILD_NUMBER >= 2)) || (ETA_VERSION > 9)
+import GHC.IO.FD
+import System.Posix.Types     (Channel)
+import System.Posix.Internals (c_close)
+import Control.Monad
+import Java
+import Java.Array
+import Data.Maybe
+#endif
 
 import Network.Socket.Internal
 import Network.Socket.Types
@@ -248,26 +257,20 @@ type ServiceName    = String
 --    of others (recvFrom, sendFd, recvFd) will block all threads - if this
 --    is a problem, -threaded is the workaround.
 --
-##if defined(mingw32_HOST_OS)
-##define SAFE_ON_WIN safe
-##else
-##define SAFE_ON_WIN unsafe
-##endif
+#define SAFE_ON_WIN safe
 
 -----------------------------------------------------------------------------
 -- Socket types
 
-#if defined(mingw32_HOST_OS)
-socket2FD  (MkSocket fd _ _ _ _) =
-  -- HACK, 1 means True
-  FD{fdFD = fd,fdIsSocket_ = 1}
-#endif
+socket2FD  (MkSocket fd _ _ _ _) = do
+  blocking <- isBlocking fd
+  return $ FD { fdFD = FDGeneric fd, fdIsNonBlocking = not blocking }
 
 -- | Smart constructor for constructing a 'Socket'. It should only be
 -- called once for every new file descriptor. The caller must make
 -- sure that the socket is in non-blocking mode. See
 -- 'setNonBlockIfNeeded'.
-mkSocket :: CInt
+mkSocket :: Channel
          -> Family
          -> SocketType
          -> ProtocolNumber
@@ -279,7 +282,7 @@ mkSocket fd fam sType pNum stat = do
    return (MkSocket fd fam sType pNum mStat)
 
 
-fdSocket :: Socket -> CInt
+fdSocket :: Socket -> Channel
 fdSocket (MkSocket fd _ _ _ _) = fd
 
 -- | This is the default protocol for a given service.
@@ -344,8 +347,7 @@ socket :: Family         -- Family Name (usually AF_INET)
        -> IO Socket      -- Unconnected Socket
 socket family stype protocol = do
     c_stype <- packSocketTypeOrThrow "socket" stype
-    fd <- throwSocketErrorIfMinus1Retry "Network.Socket.socket" $
-                c_socket (packFamily family) c_stype protocol
+    fd      <- c_socket (packFamily family) c_stype protocol
     setNonBlockIfNeeded fd
     socket_status <- newMVar NotConnected
     withSocketsDo $ return ()
@@ -398,7 +400,7 @@ foreign import ccall unsafe "socketpair"
 --
 -- Depending on the platform this is required when using sockets from file
 -- descriptors that are passed in through 'recvFd' or other means.
-setNonBlockIfNeeded :: CInt -> IO ()
+setNonBlockIfNeeded :: Channel -> IO ()
 setNonBlockIfNeeded fd =
     System.Posix.Internals.setNonBlockingFD fd True
 
@@ -418,12 +420,11 @@ bind (MkSocket s _family _stype _protocol socketStatus) addr = do
  if status /= NotConnected
   then
    ioError $ userError $
-     "Network.Socket.bind: can't bind to socket with status " ++ show status
+     "Network.Socket.bind: can't bind to socket with non-default status."
   else do
-   withSockAddr addr $ \p_addr sz -> do
-   _status <- throwSocketErrorIfMinus1Retry "Network.Socket.bind" $
-     c_bind s p_addr (fromIntegral sz)
-   return Bound
+   withSockAddr addr $ \saddr -> do
+     _status <- c_bind s saddr
+     return (Bound addr)
 
 -----------------------------------------------------------------------------
 -- Connecting a socket
@@ -434,40 +435,28 @@ connect :: Socket    -- Unconnected Socket
         -> IO ()
 connect sock@(MkSocket s _family _stype _protocol socketStatus) addr = withSocketsDo $ do
  modifyMVar_ socketStatus $ \currentStatus -> do
- if currentStatus /= NotConnected && currentStatus /= Bound
+ if shouldError currentStatus
   then
     ioError $ userError $
-      errLoc ++ ": can't connect to socket with status " ++ show currentStatus
+      errLoc ++ ": can't connect to socket with status that is not bound or default."
   else do
-    withSockAddr addr $ \p_addr sz -> do
+    withSockAddr addr $ \saddr -> do
 
     let connectLoop = do
-           r <- c_connect s p_addr (fromIntegral sz)
-           if r == -1
-               then do
-#if !(defined(HAVE_WINSOCK2_H))
-                   err <- getErrno
-                   case () of
-                     _ | err == eINTR       -> connectLoop
-                     _ | err == eINPROGRESS -> connectBlocked
---                   _ | err == eAGAIN      -> connectBlocked
-                     _otherwise             -> throwSocketError errLoc
-#else
-                   throwSocketError errLoc
-#endif
-               else return ()
+           connected <- c_connect s saddr
+           unless connected $ do
+             connectBlocked
+             connectLoop
 
-        connectBlocked = do
-           threadWaitWrite (fromIntegral s)
-           err <- getSocketOption sock SoError
-           if (err == 0)
-                then return ()
-                else throwSocketErrorCode errLoc (fromIntegral err)
+        connectBlocked = threadWaitConnect s
 
     connectLoop
     return Connected
  where
    errLoc = "Network.Socket.connect: " ++ show sock
+   shouldError NotConnected = False
+   shouldError (Bound _) = False
+   shouldError _ = True
 
 -----------------------------------------------------------------------------
 -- Listen
@@ -480,14 +469,12 @@ listen :: Socket  -- Connected & Bound Socket
        -> IO ()
 listen (MkSocket s _family _stype _protocol socketStatus) backlog = do
  modifyMVar_ socketStatus $ \ status -> do
- if status /= Bound
-   then
-     ioError $ userError $
-       "Network.Socket.listen: can't listen on socket with status " ++ show status
-   else do
-     throwSocketErrorIfMinus1Retry_ "Network.Socket.listen" $
-       c_listen s (fromIntegral backlog)
-     return Listening
+ if | Bound sockAddr <- status -> do
+      withSockAddr sockAddr $ \saddr -> c_listen s saddr (fromIntegral backlog)
+      return Listening
+    | otherwise ->
+      ioError $ userError $
+        "Network.Socket.listen: can't listen on socket with non-bound status."
 
 -----------------------------------------------------------------------------
 -- Accept
@@ -514,51 +501,20 @@ accept sock@(MkSocket s family stype protocol status) = do
    then
      ioError $ userError $
        "Network.Socket.accept: can't accept socket (" ++
-         show (family, stype, protocol) ++ ") with status " ++
-         show currentStatus
+         show (family, stype, protocol) ++ ") with status not in position to accept" ++
+         "connections."
    else do
-     let sz = sizeOfSockAddrByFamily family
-     allocaBytes sz $ \ sockaddr -> do
-#if defined(mingw32_HOST_OS)
-     new_sock <-
-        if threaded
-           then with (fromIntegral sz) $ \ ptr_len ->
-                  throwSocketErrorIfMinus1Retry "Network.Socket.accept" $
-                    c_accept_safe s sockaddr ptr_len
-           else do
-                paramData <- c_newAcceptParams s (fromIntegral sz) sockaddr
-                rc        <- asyncDoProc c_acceptDoProc paramData
-                new_sock  <- c_acceptNewSock    paramData
-                c_free paramData
-                when (rc /= 0) $
-                     throwSocketErrorCode "Network.Socket.accept" (fromIntegral rc)
-                return new_sock
-#else
-     with (fromIntegral sz) $ \ ptr_len -> do
-# ifdef HAVE_ACCEPT4
-     new_sock <- throwSocketErrorIfMinus1RetryMayBlock "Network.Socket.accept"
-                        (threadWaitRead (fromIntegral s))
-                        (c_accept4 s sockaddr ptr_len (#const SOCK_NONBLOCK))
-# else
-     new_sock <- throwSocketErrorWaitRead sock "Network.Socket.accept"
-                        (c_accept s sockaddr ptr_len)
+     new_sock <- onNothingRetry $ c_accept s
+     addr <- newSockAddr new_sock
      setNonBlockIfNeeded new_sock
-# endif /* HAVE_ACCEPT4 */
-#endif
-     addr <- peekSockAddr sockaddr
      new_status <- newMVar Connected
-     return ((MkSocket new_sock family stype protocol new_status), addr)
-
-#if defined(mingw32_HOST_OS)
-foreign import ccall unsafe "HsNet.h acceptNewSock"
-  c_acceptNewSock :: Ptr () -> IO CInt
-foreign import ccall unsafe "HsNet.h newAcceptParams"
-  c_newAcceptParams :: CInt -> CInt -> Ptr a -> IO (Ptr ())
-foreign import ccall unsafe "HsNet.h &acceptDoProc"
-  c_acceptDoProc :: FunPtr (Ptr () -> IO Int)
-foreign import ccall unsafe "free"
-  c_free:: Ptr a -> IO ()
-#endif
+     return ((MkSocket new_sock family (toStype stype) protocol new_status), addr)
+  where onNothingRetry io = do
+          mResult <- io
+          case mResult of
+            Nothing -> threadWaitAccept s >> onNothingRetry io
+            Just ch -> return ch
+        toStype (ServerSocket s) = s
 
 -----------------------------------------------------------------------------
 -- ** Sending and receiving data
@@ -599,11 +555,10 @@ sendBufTo :: Socket            -- (possibly) bound/connected Socket
           -> SockAddr
           -> IO Int            -- Number of Bytes sent
 sendBufTo sock@(MkSocket s _family _stype _protocol _status) ptr nbytes addr = do
- withSockAddr addr $ \p_addr sz -> do
+ withSockAddr addr $ \p_addr -> do
    liftM fromIntegral $
      throwSocketErrorWaitWrite sock "Network.Socket.sendTo" $
-        c_sendto s ptr (fromIntegral $ nbytes) 0{-flags-}
-                        p_addr (fromIntegral sz)
+        c_sendto s ptr (fromIntegral $ nbytes) p_addr
 
 -- | Receive data from the socket. The socket need not be in a
 -- connected state. Returns @(bytes, nbytes, address)@ where @bytes@
@@ -632,27 +587,27 @@ recvFrom sock nbytes =
 recvBufFrom :: Socket -> Ptr a -> Int -> IO (Int, SockAddr)
 recvBufFrom sock@(MkSocket s family _stype _protocol _status) ptr nbytes
  | nbytes <= 0 = ioError (mkInvalidRecvArgError "Network.Socket.recvFrom")
- | otherwise   =
-    withNewSockAddr family $ \ptr_addr sz -> do
-      alloca $ \ptr_len -> do
-        poke ptr_len (fromIntegral sz)
-        len <- throwSocketErrorWaitRead sock "Network.Socket.recvFrom" $
-                   c_recvfrom s ptr (fromIntegral nbytes) 0{-flags-}
-                                ptr_addr ptr_len
-        let len' = fromIntegral len
-        if len' == 0
-         then ioError (mkEOFError "Network.Socket.recvFrom")
-         else do
-           flg <- isConnected sock
-             -- For at least one implementation (WinSock 2), recvfrom() ignores
-             -- filling in the sockaddr for connected TCP sockets. Cope with
-             -- this by using getPeerName instead.
-           sockaddr <-
-                if flg then
-                   getPeerName sock
-                else
-                   peekSockAddr ptr_addr
-           return (len', sockaddr)
+ | otherwise   = error "recvBufFrom: Not implemented yet"
+    -- withNewSockAddr family $ \ptr_addr sz -> do
+    --   alloca $ \ptr_len -> do
+    --     poke ptr_len (fromIntegral sz)
+    --     len <- throwSocketErrorWaitRead sock "Network.Socket.recvFrom" $
+    --                c_recvfrom s ptr (fromIntegral nbytes) 0{-flags-}
+    --                             ptr_addr ptr_len
+    --     let len' = fromIntegral len
+    --     if len' == 0
+    --      then ioError (mkEOFError "Network.Socket.recvFrom")
+    --      else do
+    --        flg <- isConnected sock
+    --          -- For at least one implementation (WinSock 2), recvfrom() ignores
+    --          -- filling in the sockaddr for connected TCP sockets. Cope with
+    --          -- this by using getPeerName instead.
+    --        sockaddr <-
+    --             if flg then
+    --                getPeerName sock
+    --             else
+    --                peekSockAddr ptr_addr
+    --        return (len', sockaddr)
 
 -----------------------------------------------------------------------------
 -- send & recv
@@ -679,23 +634,18 @@ sendBuf :: Socket     -- Bound/Connected Socket
         -> Int        -- Length of the buffer
         -> IO Int     -- Number of Bytes sent
 sendBuf sock@(MkSocket s _family _stype _protocol _status) str len = do
+   fd <- socket2FD sock
    liftM fromIntegral $
-#if defined(mingw32_HOST_OS)
 -- writeRawBufferPtr is supposed to handle checking for errors, but it's broken
 -- on x86_64 because of GHC bug #12010 so we duplicate the check here. The call
 -- to throwSocketErrorIfMinus1Retry can be removed when no GHC version with the
 -- bug is supported.
     throwSocketErrorIfMinus1Retry "Network.Socket.sendBuf" $ writeRawBufferPtr
       "Network.Socket.sendBuf"
-      (socket2FD sock)
+      fd
       (castPtr str)
       0
       (fromIntegral len)
-#else
-     throwSocketErrorWaitWrite sock "Network.Socket.sendBuf" $
-        c_send s str (fromIntegral len) 0{-flags-}
-#endif
-
 
 -- | Receive data from the socket.  The socket must be in a connected
 -- state. This function may return fewer bytes than specified.  If the
@@ -739,16 +689,12 @@ recvBuf :: Socket -> Ptr Word8 -> Int -> IO Int
 recvBuf sock@(MkSocket s _family _stype _protocol _status) ptr nbytes
  | nbytes <= 0 = ioError (mkInvalidRecvArgError "Network.Socket.recvBuf")
  | otherwise   = do
+        fd <- socket2FD sock
         len <-
-#if defined(mingw32_HOST_OS)
 -- see comment in sendBuf above.
             throwSocketErrorIfMinus1Retry "Network.Socket.recvBuf" $
                 readRawBufferPtr "Network.Socket.recvBuf"
-                (socket2FD sock) ptr 0 (fromIntegral nbytes)
-#else
-               throwSocketErrorWaitRead sock "Network.Socket.recvBuf" $
-                   c_recv s (castPtr ptr) (fromIntegral nbytes) 0{-flags-}
-#endif
+                fd ptr 0 (fromIntegral nbytes)
         let len' = fromIntegral len
         if len' == 0
          then ioError (mkEOFError "Network.Socket.recvBuf")
@@ -788,21 +734,12 @@ socketPort (MkSocket _ family _ _ _) =
 -- local machine is $getSocketName$.
 
 getPeerName   :: Socket -> IO SockAddr
-getPeerName (MkSocket s family _ _ _) = do
- withNewSockAddr family $ \ptr sz -> do
-   with (fromIntegral sz) $ \int_star -> do
-   throwSocketErrorIfMinus1Retry_ "Network.Socket.getPeerName" $
-     c_getpeername s ptr int_star
-   _sz <- peek int_star
-   peekSockAddr ptr
+getPeerName (MkSocket s family _ _ _) =
+  error $ "Network.Socket.getPeerName: Not implemented yet."
 
 getSocketName :: Socket -> IO SockAddr
-getSocketName (MkSocket s family _ _ _) = do
- withNewSockAddr family $ \ptr sz -> do
-   with (fromIntegral sz) $ \int_star -> do
-   throwSocketErrorIfMinus1Retry_ "Network.Socket.getSocketName" $
-     c_getsockname s ptr int_star
-   peekSockAddr ptr
+getSocketName (MkSocket s family _ _ _) =
+  error $ "Network.Socket.getSocketName: Not implemented yet."
 
 -----------------------------------------------------------------------------
 -- Socket Properties
@@ -846,7 +783,7 @@ isSupportedSocketOption = isJust . packSocketOption
 -- corresponding C option level constant (e.g. SOL_SOCKET) and value is
 -- the option constant itself (e.g. SO_DEBUG)
 -- If either constant does not exist, return Nothing.
-packSocketOption :: SocketOption -> Maybe (CInt, CInt)
+packSocketOption :: SocketOption -> Maybe SOption
 packSocketOption so =
   -- The Just here is a hack to disable GHC's overlapping pattern detection:
   -- the problem is if all constants are present, the fallback pattern is
@@ -858,90 +795,19 @@ packSocketOption so =
   -- would be a serious nuisance.
   -- (NB: comments elsewhere in this file refer to this one)
   case Just so of
-#ifdef SOL_SOCKET
-#ifdef SO_DEBUG
-    Just Debug         -> Just ((#const SOL_SOCKET), (#const SO_DEBUG))
-#endif
-#ifdef SO_REUSEADDR
-    Just ReuseAddr     -> Just ((#const SOL_SOCKET), (#const SO_REUSEADDR))
-#endif
-#ifdef SO_TYPE
-    Just Type          -> Just ((#const SOL_SOCKET), (#const SO_TYPE))
-#endif
-#ifdef SO_ERROR
-    Just SoError       -> Just ((#const SOL_SOCKET), (#const SO_ERROR))
-#endif
-#ifdef SO_DONTROUTE
-    Just DontRoute     -> Just ((#const SOL_SOCKET), (#const SO_DONTROUTE))
-#endif
-#ifdef SO_BROADCAST
-    Just Broadcast     -> Just ((#const SOL_SOCKET), (#const SO_BROADCAST))
-#endif
-#ifdef SO_SNDBUF
-    Just SendBuffer    -> Just ((#const SOL_SOCKET), (#const SO_SNDBUF))
-#endif
-#ifdef SO_RCVBUF
-    Just RecvBuffer    -> Just ((#const SOL_SOCKET), (#const SO_RCVBUF))
-#endif
-#ifdef SO_KEEPALIVE
-    Just KeepAlive     -> Just ((#const SOL_SOCKET), (#const SO_KEEPALIVE))
-#endif
-#ifdef SO_OOBINLINE
-    Just OOBInline     -> Just ((#const SOL_SOCKET), (#const SO_OOBINLINE))
-#endif
-#ifdef SO_LINGER
-    Just Linger        -> Just ((#const SOL_SOCKET), (#const SO_LINGER))
-#endif
-#ifdef SO_REUSEPORT
-    Just ReusePort     -> Just ((#const SOL_SOCKET), (#const SO_REUSEPORT))
-#endif
-#ifdef SO_RCVLOWAT
-    Just RecvLowWater  -> Just ((#const SOL_SOCKET), (#const SO_RCVLOWAT))
-#endif
-#ifdef SO_SNDLOWAT
-    Just SendLowWater  -> Just ((#const SOL_SOCKET), (#const SO_SNDLOWAT))
-#endif
-#ifdef SO_RCVTIMEO
-    Just RecvTimeOut   -> Just ((#const SOL_SOCKET), (#const SO_RCVTIMEO))
-#endif
-#ifdef SO_SNDTIMEO
-    Just SendTimeOut   -> Just ((#const SOL_SOCKET), (#const SO_SNDTIMEO))
-#endif
-#ifdef SO_USELOOPBACK
-    Just UseLoopBack   -> Just ((#const SOL_SOCKET), (#const SO_USELOOPBACK))
-#endif
-#endif // SOL_SOCKET
-#if HAVE_DECL_IPPROTO_IP
-#ifdef IP_TTL
-    Just TimeToLive    -> Just ((#const IPPROTO_IP), (#const IP_TTL))
-#endif
-#endif // HAVE_DECL_IPPROTO_IP
-#if HAVE_DECL_IPPROTO_TCP
-#ifdef TCP_MAXSEG
-    Just MaxSegment    -> Just ((#const IPPROTO_TCP), (#const TCP_MAXSEG))
-#endif
-#ifdef TCP_NODELAY
-    Just NoDelay       -> Just ((#const IPPROTO_TCP), (#const TCP_NODELAY))
-#endif
-#ifdef TCP_USER_TIMEOUT
-    Just UserTimeout   -> Just ((#const IPPROTO_TCP), (#const TCP_USER_TIMEOUT))
-#endif
-#ifdef TCP_CORK
-    Just Cork          -> Just ((#const IPPROTO_TCP), (#const TCP_CORK))
-#endif
-#endif // HAVE_DECL_IPPROTO_TCP
-#if HAVE_DECL_IPPROTO_IPV6
-#if HAVE_DECL_IPV6_V6ONLY
-    Just IPv6Only      -> Just ((#const IPPROTO_IPV6), (#const IPV6_V6ONLY))
-#endif
-#endif // HAVE_DECL_IPPROTO_IPV6
-    Just (CustomSockOpt opt) -> Just opt
-    _             -> Nothing
+    Just ReuseAddr     -> Just sO_REUSEADDR
+    Just Broadcast     -> Just sO_BROADCAST
+    Just SendBuffer    -> Just sO_SNDBUF
+    Just RecvBuffer    -> Just sO_RCVBUF
+    Just KeepAlive     -> Just sO_KEEPALIVE
+    Just Linger        -> Just sO_LINGER
+    Just NoDelay       -> Just tCP_NODELAY
+    _                  -> Nothing
 
 -- | Return the option level and option value if they exist,
 -- otherwise throw an error that begins "Network.Socket." ++ the String
 -- parameter
-packSocketOption' :: String -> SocketOption -> IO (CInt, CInt)
+packSocketOption' :: String -> SocketOption -> IO SOption
 packSocketOption' caller so = maybe err return (packSocketOption so)
  where
   err = ioError . userError . concat $ ["Network.Socket.", caller,
@@ -954,13 +820,8 @@ setSocketOption :: Socket
                 -> Int          -- Option Value
                 -> IO ()
 setSocketOption (MkSocket s _ _ _ _) so v = do
-   (level, opt) <- packSocketOption' "setSocketOption" so
-   with (fromIntegral v) $ \ptr_v -> do
-   throwSocketErrorIfMinus1_ "Network.Socket.setSocketOption" $
-       c_setsockopt s level opt ptr_v
-          (fromIntegral (sizeOf (undefined :: CInt)))
-   return ()
-
+   opt <- packSocketOption' "setSocketOption" so
+   c_setsockopt s opt (fromIntegral v)
 
 -- | Get a socket option that gives an Int value.
 -- There is currently no API to get e.g. the timeval socket options
@@ -968,13 +829,8 @@ getSocketOption :: Socket
                 -> SocketOption  -- Option Name
                 -> IO Int        -- Option Value
 getSocketOption (MkSocket s _ _ _ _) so = do
-   (level, opt) <- packSocketOption' "getSocketOption" so
-   alloca $ \ptr_v ->
-     with (fromIntegral (sizeOf (undefined :: CInt))) $ \ptr_sz -> do
-       throwSocketErrorIfMinus1Retry_ "Network.Socket.getSocketOption" $
-         c_getsockopt s level opt ptr_v ptr_sz
-       fromIntegral `liftM` peek ptr_v
-
+   opt <- packSocketOption' "getSocketOption" so
+   fmap fromIntegral $ c_getsockopt s opt
 
 #if defined(HAVE_STRUCT_UCRED) || defined(HAVE_GETPEEREID)
 -- | Returns the processID, userID and groupID of the socket's peer.
@@ -1016,10 +872,6 @@ getPeerEid sock = do
 #endif
 #endif
 
-##if !(MIN_VERSION_base(4,3,1))
-closeFdWith closer fd = closer fd
-##endif
-
 #if defined(DOMAIN_SOCKET_SUPPORT)
 -- sending/receiving ancillary socket data; low-level mechanism
 -- for transmitting file descriptors, mainly.
@@ -1054,12 +906,12 @@ aNY_PORT = 0
 -- | The IPv4 wild card address.
 
 iNADDR_ANY :: HostAddress
-iNADDR_ANY = htonl (#const INADDR_ANY)
+iNADDR_ANY = 0
 
 -- | Converts the from host byte order to network byte order.
-foreign import CALLCONV unsafe "htonl" htonl :: Word32 -> Word32
--- | Converts the from network byte order to host byte order.
-foreign import CALLCONV unsafe "ntohl" ntohl :: Word32 -> Word32
+-- foreign import CALLCONV unsafe "htonl" htonl :: Word32 -> Word32
+-- -- | Converts the from network byte order to host byte order.
+-- foreign import CALLCONV unsafe "ntohl" ntohl :: Word32 -> Word32
 
 #if defined(IPV6_SOCKET_SUPPORT)
 -- | The IPv6 wild card address.
@@ -1069,10 +921,10 @@ iN6ADDR_ANY = (0, 0, 0, 0)
 #endif
 
 sOMAXCONN :: Int
-sOMAXCONN = #const SOMAXCONN
+sOMAXCONN = 50
 
 sOL_SOCKET :: Int
-sOL_SOCKET = #const SOL_SOCKET
+sOL_SOCKET = 0
 
 #ifdef SCM_RIGHTS
 sCM_RIGHTS :: Int
@@ -1121,7 +973,7 @@ close (MkSocket s _ _ _ socketStatus) = do
          ioError (userError ("close: converted to a Handle, use hClose instead"))
      Closed ->
          return status
-     _ -> closeFdWith (closeFd . fromIntegral) (fromIntegral s) >> return Closed
+     _ -> closeFdWith closeFd s >> return Closed
 
 -- -----------------------------------------------------------------------------
 
@@ -1140,7 +992,9 @@ isConnected (MkSocket _ _ _ _ status) = do
 isBound :: Socket -> IO Bool
 isBound (MkSocket _ _ _ _ status) = do
     value <- readMVar status
-    return (value == Bound)
+    return $ case value of
+      Bound _ -> True
+      _ -> False
 
 isListening :: Socket -> IO Bool
 isListening (MkSocket _ _ _  _ status) = do
@@ -1172,17 +1026,14 @@ isAcceptable (MkSocket _ _ _ _ status) = do
 
 inet_addr :: String -> IO HostAddress
 inet_addr ipstr = withSocketsDo $ do
-   withCString ipstr $ \str -> do
-   had <- c_inet_addr str
+   had <- c_inet_addr ipstr
    if had == -1
     then ioError $ userError $
       "Network.Socket.inet_addr: Malformed address: " ++ ipstr
     else return had  -- network byte order
 
 inet_ntoa :: HostAddress -> IO String
-inet_ntoa haddr = withSocketsDo $ do
-  pstr <- c_inet_ntoa haddr
-  peekCString pstr
+inet_ntoa haddr = withSocketsDo $ c_inet_ntoa haddr
 
 -- | Turns a Socket into an 'Handle'. By default, the new handle is
 -- unbuffered. Use 'System.IO.hSetBuffering' to change the buffering.
@@ -1199,7 +1050,7 @@ socketToHandle s@(MkSocket fd _ _ _ socketStatus) mode = do
     if status == ConvertedToHandle
         then ioError (userError ("socketToHandle: already a Handle"))
         else do
-    h <- fdToHandle' (fromIntegral fd) (Just GHC.IO.Device.Stream) True (show s) mode True{-bin-}
+    h <- fdToHandle' fd (Just GHC.IO.Device.Stream) True Nothing mode True{-bin-}
     hSetBuffering h NoBuffering
     return (ConvertedToHandle, h)
 
@@ -1280,14 +1131,14 @@ aiFlagMapping =
 #else
      (AI_ALL, 0),
 #endif
-     (AI_CANONNAME, #const AI_CANONNAME),
-     (AI_NUMERICHOST, #const AI_NUMERICHOST),
+     (AI_CANONNAME, 0),
+     (AI_NUMERICHOST, 0),
 #if HAVE_DECL_AI_NUMERICSERV
      (AI_NUMERICSERV, #const AI_NUMERICSERV),
 #else
      (AI_NUMERICSERV, 0),
 #endif
-     (AI_PASSIVE, #const AI_PASSIVE),
+     (AI_PASSIVE, 0),
 #if HAVE_DECL_AI_V4MAPPED
      (AI_V4MAPPED, #const AI_V4MAPPED)
 #else
@@ -1311,48 +1162,6 @@ data AddrInfo =
         }
     deriving (Eq, Show, Typeable)
 
-instance Storable AddrInfo where
-    sizeOf    _ = #const sizeof(struct addrinfo)
-    alignment _ = alignment (undefined :: CInt)
-
-    peek p = do
-        ai_flags <- (#peek struct addrinfo, ai_flags) p
-        ai_family <- (#peek struct addrinfo, ai_family) p
-        ai_socktype <- (#peek struct addrinfo, ai_socktype) p
-        ai_protocol <- (#peek struct addrinfo, ai_protocol) p
-        ai_addr <- (#peek struct addrinfo, ai_addr) p >>= peekSockAddr
-        ai_canonname_ptr <- (#peek struct addrinfo, ai_canonname) p
-
-        ai_canonname <- if ai_canonname_ptr == nullPtr
-                        then return Nothing
-                        else liftM Just $ peekCString ai_canonname_ptr
-
-        socktype <- unpackSocketType' "AddrInfo.peek" ai_socktype
-        return (AddrInfo
-                {
-                 addrFlags = unpackBits aiFlagMapping ai_flags,
-                 addrFamily = unpackFamily ai_family,
-                 addrSocketType = socktype,
-                 addrProtocol = ai_protocol,
-                 addrAddress = ai_addr,
-                 addrCanonName = ai_canonname
-                })
-
-    poke p (AddrInfo flags family socketType protocol _ _) = do
-        c_stype <- packSocketTypeOrThrow "AddrInfo.poke" socketType
-
-        (#poke struct addrinfo, ai_flags) p (packBits aiFlagMapping flags)
-        (#poke struct addrinfo, ai_family) p (packFamily family)
-        (#poke struct addrinfo, ai_socktype) p c_stype
-        (#poke struct addrinfo, ai_protocol) p protocol
-
-        -- stuff below is probably not needed, but let's zero it for safety
-
-        (#poke struct addrinfo, ai_addrlen) p (0::CSize)
-        (#poke struct addrinfo, ai_addr) p nullPtr
-        (#poke struct addrinfo, ai_canonname) p nullPtr
-        (#poke struct addrinfo, ai_next) p nullPtr
-
 -- | Flags that control the querying behaviour of 'getNameInfo'.
 --   For more information, see <https://tools.ietf.org/html/rfc3493#page-30>
 data NameInfoFlag =
@@ -1379,11 +1188,11 @@ data NameInfoFlag =
 
 niFlagMapping :: [(NameInfoFlag, CInt)]
 
-niFlagMapping = [(NI_DGRAM, #const NI_DGRAM),
-                 (NI_NAMEREQD, #const NI_NAMEREQD),
-                 (NI_NOFQDN, #const NI_NOFQDN),
-                 (NI_NUMERICHOST, #const NI_NUMERICHOST),
-                 (NI_NUMERICSERV, #const NI_NUMERICSERV)]
+niFlagMapping = [(NI_DGRAM, 0),
+                 (NI_NAMEREQD, 1),
+                 (NI_NOFQDN, 2),
+                 (NI_NUMERICHOST, 3),
+                 (NI_NUMERICSERV, 4)]
 
 -- | Default hints for address lookup with 'getAddrInfo'.  The values
 -- of the 'addrAddress' and 'addrCanonName' fields are 'undefined',
@@ -1453,58 +1262,30 @@ getAddrInfo :: Maybe AddrInfo -- ^ preferred socket type or protocol
             -> Maybe ServiceName -- ^ service name to look up
             -> IO [AddrInfo] -- ^ resolved addresses, with "best" first
 
-getAddrInfo hints node service = withSocketsDo $
-  maybeWith withCString node $ \c_node ->
-    maybeWith withCString service $ \c_service ->
-      maybeWith with filteredHints $ \c_hints ->
-        alloca $ \ptr_ptr_addrs -> do
-          ret <- c_getaddrinfo c_node c_service c_hints ptr_ptr_addrs
-          case ret of
-            0 -> do ptr_addrs <- peek ptr_ptr_addrs
-                    ais <- followAddrInfo ptr_addrs
-                    c_freeaddrinfo ptr_addrs
-                    return ais
-            _ -> do err <- gai_strerror ret
-                    ioError (ioeSetErrorString
-                             (mkIOError NoSuchThing "Network.Socket.getAddrInfo" Nothing
-                              Nothing) err)
-    -- Leaving out the service and using AI_NUMERICSERV causes a
-    -- segfault on OS X 10.8.2. This code removes AI_NUMERICSERV
-    -- (which has no effect) in that case.
-  where
-#if defined(darwin_HOST_OS)
-    filteredHints = case service of
-        Nothing -> fmap (\ h -> h { addrFlags = delete AI_NUMERICSERV (addrFlags h) }) hints
-        _       -> hints
-#else
-    filteredHints = hints
-#endif
-
-followAddrInfo :: Ptr AddrInfo -> IO [AddrInfo]
-
-followAddrInfo ptr_ai | ptr_ai == nullPtr = return []
-                      | otherwise = do
-    a <- peek ptr_ai
-    as <- (#peek struct addrinfo, ai_next) ptr_ai >>= followAddrInfo
-    return (a:as)
-
-foreign import ccall safe "hsnet_getaddrinfo"
-    c_getaddrinfo :: CString -> CString -> Ptr AddrInfo -> Ptr (Ptr AddrInfo)
-                  -> IO CInt
-
-foreign import ccall safe "hsnet_freeaddrinfo"
-    c_freeaddrinfo :: Ptr AddrInfo -> IO ()
-
-gai_strerror :: CInt -> IO String
-
-#ifdef HAVE_GAI_STRERROR
-gai_strerror n = c_gai_strerror n >>= peekCString
-
-foreign import ccall safe "gai_strerror"
-    c_gai_strerror :: CInt -> IO CString
-#else
-gai_strerror n = ioError $ userError $ "Network.Socket.gai_strerror not supported: " ++ show n
-#endif
+getAddrInfo mHints node service = withSocketsDo $ do
+  addresses <- c_getaddrinfo (fromMaybe "0.0.0.0" node)
+  return $ map toAddrInfo $ filter filterFun $ fromJava addresses
+  where toAddrInfo inetAddr = defaultHints {
+          addrAddress    = SockAddrInet port (inetAddrInt inetAddr),
+          addrSocketType = maybe (addrSocketType defaultHints) addrSocketType mHints,
+          addrFamily     = if isIPv6 inetAddr then AF_INET6 else AF_INET
+          }
+        filterFun  =
+          case addrFamilySelect of
+            AF_INET  -> not . isIPv6
+            AF_INET6 -> isIPv6
+            _        -> const True
+        addrFamilySelect = maybe (addrFamily defaultHints) addrFamily mHints
+        port
+          | Just port' <- service
+          = read port'
+          | otherwise = 0
+
+foreign import CALLCONV unsafe "@static java.net.InetAddress.getAllByName"
+  c_getaddrinfo :: String -> IO InetAddressArray
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.isIPv6"
+  isIPv6 :: InetAddress -> Bool
 
 withCStringIf :: Bool -> Int -> (CSize -> CString -> IO a) -> IO a
 withCStringIf False _ f = f 0 nullPtr
@@ -1524,34 +1305,31 @@ withCStringIf True n f = allocaBytes n (f (fromIntegral n))
 --   (hostName, _) <- getNameInfo [] True False myAddress
 -- @
 
+foreign import CALLCONV unsafe "@static eta.network.Utils.inet6_ntoa"
+  inet6_ntoa :: JIntArray -> String
+
 getNameInfo :: [NameInfoFlag] -- ^ flags to control lookup behaviour
             -> Bool -- ^ whether to look up a hostname
             -> Bool -- ^ whether to look up a service name
             -> SockAddr -- ^ the address to look up
             -> IO (Maybe HostName, Maybe ServiceName)
 
-getNameInfo flags doHost doService addr = withSocketsDo $
-  withCStringIf doHost (#const NI_MAXHOST) $ \c_hostlen c_host ->
-    withCStringIf doService (#const NI_MAXSERV) $ \c_servlen c_serv -> do
-      withSockAddr addr $ \ptr_addr sz -> do
-        ret <- c_getnameinfo ptr_addr (fromIntegral sz) c_host c_hostlen
-                             c_serv c_servlen (packBits niFlagMapping flags)
-        case ret of
-          0 -> do
-            let peekIf doIf c_val = if doIf
-                                     then liftM Just $ peekCString c_val
-                                     else return Nothing
-            host <- peekIf doHost c_host
-            serv <- peekIf doService c_serv
-            return (host, serv)
-          _ -> do err <- gai_strerror ret
-                  ioError (ioeSetErrorString
-                           (mkIOError NoSuchThing "Network.Socket.getNameInfo" Nothing
-                            Nothing) err)
-
-foreign import ccall safe "hsnet_getnameinfo"
-    c_getnameinfo :: Ptr SockAddr -> CInt{-CSockLen???-} -> CString -> CSize -> CString
-                  -> CSize -> CInt -> IO CInt
+getNameInfo _flags _doHost _doService addr =
+  case addr of
+    SockAddrInet6 _ _ addr _ -> do
+      let (ip1,ip2,ip3,ip4) = addr
+      hostName <- c_getnameinfo $ toJByteArray (concatMap word32to8 [ip1,ip2,ip3,ip4])
+      return (Just hostName, Nothing)
+    SockAddrInet _ addr -> do
+      hostName <- c_getnameinfo $ toJByteArray (word32to8 addr)
+      return (Just hostName, Nothing)
+  where word32to8 w32 = map fromIntegral [(w32 `shiftR` 24) .&. 0xFF
+                                         ,(w32 `shiftR` 16) .&. 0xFF
+                                         ,(w32 `shiftR` 8)  .&. 0xFF
+                                         ,w32 .&. 0xFF]
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.getNameInfo"
+  c_getnameinfo :: JByteArray -> IO String
 #endif
 
 mkInvalidRecvArgError :: String -> IOError
@@ -1565,71 +1343,101 @@ mkEOFError loc = ioeSetErrorString (mkIOError EOF loc Nothing Nothing) "end of f
 -- ---------------------------------------------------------------------------
 -- foreign imports from the C library
 
-foreign import ccall unsafe "hsnet_inet_ntoa"
-  c_inet_ntoa :: HostAddress -> IO (Ptr CChar)
+foreign import CALLCONV unsafe "@static eta.network.Utils.inet_ntoa"
+  c_inet_ntoa :: HostAddress -> IO String
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.inet_addr"
+  c_inet_addr :: String -> IO HostAddress
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.shutdown"
+  c_shutdown :: Channel -> CInt -> IO CInt
+
+closeFd :: Channel -> IO ()
+closeFd fd = c_close fd
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.socket"
+  c_socket :: CInt -> CInt -> CInt -> IO Channel
+foreign import CALLCONV unsafe "@static eta.network.Utils.bind"
+  c_bind :: Channel -> SocketAddress -> IO CInt
+foreign import CALLCONV SAFE_ON_WIN "@static eta.network.Utils.connect"
+  c_connect :: Channel -> SocketAddress -> IO Bool
+foreign import CALLCONV unsafe "@static eta.network.Utils.accept"
+  c_accept :: Channel -> IO (Maybe Channel)
+foreign import CALLCONV unsafe "@static eta.network.Utils.listen"
+  c_listen :: Channel -> SocketAddress -> CInt -> IO CInt
+
+-- foreign import CALLCONV unsafe "send"
+--   c_send :: CInt -> Ptr a -> CSize -> CInt -> IO CInt
+foreign import CALLCONV SAFE_ON_WIN "@static eta.network.Utils.sendto"
+  c_sendto :: Channel -> Ptr a -> CSize -> SocketAddress -> IO CInt
+-- foreign import CALLCONV unsafe "recv"
+--   c_recv :: CInt -> Ptr CChar -> CSize -> CInt -> IO CInt
+-- foreign import CALLCONV SAFE_ON_WIN "@static eta.network.Utils.sendto"
+--   c_recvfrom :: CInt -> Ptr a -> CSize -> CInt -> Ptr SockAddr -> IO CInt
+-- foreign import CALLCONV unsafe "getpeername"
+--   c_getpeername :: CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
+-- foreign import CALLCONV unsafe "getsockname"
+--   c_getsockname :: CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.getsockopt"
+  c_getsockopt :: Channel -> SOption -> IO CInt
+foreign import CALLCONV unsafe "@static eta.network.Utils.setsockopt"
+  c_setsockopt :: Channel -> SOption -> CInt ->  IO ()
 
-foreign import CALLCONV unsafe "inet_addr"
-  c_inet_addr :: Ptr CChar -> IO HostAddress
+#if defined(HAVE_GETPEEREID)
+foreign import CALLCONV unsafe "getpeereid"
+  c_getpeereid :: CInt -> Ptr CUInt -> Ptr CUInt -> IO CInt
+#endif
 
-foreign import CALLCONV unsafe "shutdown"
-  c_shutdown :: CInt -> CInt -> IO CInt
+foreign import CALLCONV unsafe "@static eta.network.Utils.isBlocking" isBlocking
+  :: Channel -> IO Bool
 
-closeFd :: CInt -> IO ()
-closeFd fd = throwSocketErrorIfMinus1_ "Network.Socket.close" $ c_close fd
+data {-# CLASS "java.net.SocketOption" #-} SOption = SOption (Object# SOption)
 
-#if !defined(WITH_WINSOCK)
-foreign import ccall unsafe "close"
-  c_close :: CInt -> IO CInt
-#else
-foreign import stdcall unsafe "closesocket"
-  c_close :: CInt -> IO CInt
-#endif
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.IP_MULTICAST_IF"
+  iP_MULTICAST_IF :: SOption
 
-foreign import CALLCONV unsafe "socket"
-  c_socket :: CInt -> CInt -> CInt -> IO CInt
-foreign import CALLCONV unsafe "bind"
-  c_bind :: CInt -> Ptr SockAddr -> CInt{-CSockLen???-} -> IO CInt
-foreign import CALLCONV SAFE_ON_WIN "connect"
-  c_connect :: CInt -> Ptr SockAddr -> CInt{-CSockLen???-} -> IO CInt
-#ifdef HAVE_ACCEPT4
-foreign import CALLCONV unsafe "accept4"
-  c_accept4 :: CInt -> Ptr SockAddr -> Ptr CInt{-CSockLen???-} -> CInt -> IO CInt
-#else
-foreign import CALLCONV unsafe "accept"
-  c_accept :: CInt -> Ptr SockAddr -> Ptr CInt{-CSockLen???-} -> IO CInt
-#endif
-foreign import CALLCONV unsafe "listen"
-  c_listen :: CInt -> CInt -> IO CInt
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.IP_MULTICAST_LOOP"
+  iP_MULTICAST_LOOP :: SOption
 
-#if defined(mingw32_HOST_OS)
-foreign import CALLCONV safe "accept"
-  c_accept_safe :: CInt -> Ptr SockAddr -> Ptr CInt{-CSockLen???-} -> IO CInt
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.IP_MULTICAST_TTL"
+  iP_MULTICAST_TTL :: SOption
 
-foreign import ccall unsafe "rtsSupportsBoundThreads" threaded :: Bool
-#endif
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.IP_TOS"
+  iP_TOS :: SOption
 
-foreign import CALLCONV unsafe "send"
-  c_send :: CInt -> Ptr a -> CSize -> CInt -> IO CInt
-foreign import CALLCONV SAFE_ON_WIN "sendto"
-  c_sendto :: CInt -> Ptr a -> CSize -> CInt -> Ptr SockAddr -> CInt -> IO CInt
-foreign import CALLCONV unsafe "recv"
-  c_recv :: CInt -> Ptr CChar -> CSize -> CInt -> IO CInt
-foreign import CALLCONV SAFE_ON_WIN "recvfrom"
-  c_recvfrom :: CInt -> Ptr a -> CSize -> CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
-foreign import CALLCONV unsafe "getpeername"
-  c_getpeername :: CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
-foreign import CALLCONV unsafe "getsockname"
-  c_getsockname :: CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
-
-foreign import CALLCONV unsafe "getsockopt"
-  c_getsockopt :: CInt -> CInt -> CInt -> Ptr CInt -> Ptr CInt -> IO CInt
-foreign import CALLCONV unsafe "setsockopt"
-  c_setsockopt :: CInt -> CInt -> CInt -> Ptr CInt -> CInt -> IO CInt
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.SO_BROADCAST"
+  sO_BROADCAST :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.SO_KEEPALIVE"
+  sO_KEEPALIVE :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.SO_LINGER"
+  sO_LINGER :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.SO_RCVBUF"
+  sO_RCVBUF :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.SO_REUSEADDR"
+  sO_REUSEADDR :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.SO_SNDBUF"
+  sO_SNDBUF :: SOption
+
+foreign import java unsafe
+  "@static @field java.net.StandardSocketOptions.TCP_NODELAY"
+  tCP_NODELAY :: SOption
 
-#if defined(HAVE_GETPEEREID)
-foreign import CALLCONV unsafe "getpeereid"
-  c_getpeereid :: CInt -> Ptr CUInt -> Ptr CUInt -> IO CInt
-#endif
 -- ---------------------------------------------------------------------------
 -- * Deprecated aliases
 
diff --git a/Network/Socket/ByteString.hsc b/Network/Socket/ByteString.hs
similarity index 77%
rename from Network/Socket/ByteString.hsc
rename to Network/Socket/ByteString.hs
index 2745bfd..dcc7a21 100644
--- a/Network/Socket/ByteString.hsc
+++ b/Network/Socket/ByteString.hs
@@ -59,17 +59,6 @@ import Network.Socket.ByteString.Internal
 import Network.Socket.Internal
 import Network.Socket.Types
 
-#if !defined(mingw32_HOST_OS)
-import Control.Monad (liftM, zipWithM_)
-import Foreign.Marshal.Array (allocaArray)
-import Foreign.Marshal.Utils (with)
-import Foreign.Ptr (Ptr, plusPtr)
-import Foreign.Storable (Storable(..))
-
-import Network.Socket.ByteString.IOVec (IOVec(..))
-import Network.Socket.ByteString.MsgHdr (MsgHdr(..))
-#endif
-
 -- ----------------------------------------------------------------------------
 -- Sending
 
@@ -160,19 +149,7 @@ sendAllTo sock xs addr = do
 sendMany :: Socket        -- ^ Connected socket
          -> [ByteString]  -- ^ Data to send
          -> IO ()
-#if !defined(mingw32_HOST_OS)
-sendMany sock@(MkSocket fd _ _ _ _) cs = do
-    sent <- sendManyInner
-    when (sent < totalLength cs) $ sendMany sock (remainingChunks sent cs)
-  where
-    sendManyInner =
-      liftM fromIntegral . withIOVec cs $ \(iovsPtr, iovsLen) ->
-          throwSocketErrorWaitWrite sock "Network.Socket.ByteString.sendMany" $
-              c_writev (fromIntegral fd) iovsPtr
-              (fromIntegral (min iovsLen (#const IOV_MAX)))
-#else
 sendMany sock = sendAll sock . B.concat
-#endif
 
 -- | Send data to the socket.  The recipient can be specified
 -- explicitly, so the socket need not be in a connected state.  The
@@ -186,23 +163,7 @@ sendManyTo :: Socket        -- ^ Socket
            -> [ByteString]  -- ^ Data to send
            -> SockAddr      -- ^ Recipient address
            -> IO ()
-#if !defined(mingw32_HOST_OS)
-sendManyTo sock@(MkSocket fd _ _ _ _) cs addr = do
-    sent <- liftM fromIntegral sendManyToInner
-    when (sent < totalLength cs) $ sendManyTo sock (remainingChunks sent cs) addr
-  where
-    sendManyToInner =
-      withSockAddr addr $ \addrPtr addrSize ->
-        withIOVec cs $ \(iovsPtr, iovsLen) -> do
-          let msgHdr = MsgHdr
-                addrPtr (fromIntegral addrSize)
-                iovsPtr (fromIntegral iovsLen)
-          with msgHdr $ \msgHdrPtr ->
-            throwSocketErrorWaitWrite sock "Network.Socket.ByteString.sendManyTo" $
-              c_sendmsg (fromIntegral fd) msgHdrPtr 0
-#else
 sendManyTo sock cs = sendAllTo sock (B.concat cs)
-#endif
 
 -- ----------------------------------------------------------------------------
 -- Receiving
@@ -245,42 +206,6 @@ recvFrom sock nbytes =
         str <- B.packCStringLen (ptr, len)
         return (str, sockaddr)
 
--- ----------------------------------------------------------------------------
--- Not exported
-
-#if !defined(mingw32_HOST_OS)
--- | Suppose we try to transmit a list of chunks @cs@ via a gathering write
--- operation and find that @n@ bytes were sent. Then @remainingChunks n cs@ is
--- list of chunks remaining to be sent.
-remainingChunks :: Int -> [ByteString] -> [ByteString]
-remainingChunks _ [] = []
-remainingChunks i (x:xs)
-    | i < len        = B.drop i x : xs
-    | otherwise      = let i' = i - len in i' `seq` remainingChunks i' xs
-  where
-    len = B.length x
-
--- | @totalLength cs@ is the sum of the lengths of the chunks in the list @cs@.
-totalLength :: [ByteString] -> Int
-totalLength = sum . map B.length
-
--- | @withIOVec cs f@ executes the computation @f@, passing as argument a pair
--- consisting of a pointer to a temporarily allocated array of pointers to
--- 'IOVec' made from @cs@ and the number of pointers (@length cs@).
--- /Unix only/.
-withIOVec :: [ByteString] -> ((Ptr IOVec, Int) -> IO a) -> IO a
-withIOVec cs f =
-    allocaArray csLen $ \aPtr -> do
-        zipWithM_ pokeIov (ptrs aPtr) cs
-        f (aPtr, csLen)
-  where
-    csLen = length cs
-    ptrs = iterate (`plusPtr` sizeOf (undefined :: IOVec))
-    pokeIov ptr s =
-        unsafeUseAsCStringLen s $ \(sPtr, sLen) ->
-        poke ptr $ IOVec sPtr (fromIntegral sLen)
-#endif
-
 -- ---------------------------------------------------------------------
 -- Example
 
diff --git a/Network/Socket/ByteString/Internal.hs b/Network/Socket/ByteString/Internal.hs
index 7aad1a6..2eea992 100644
--- a/Network/Socket/ByteString/Internal.hs
+++ b/Network/Socket/ByteString/Internal.hs
@@ -12,34 +12,13 @@
 module Network.Socket.ByteString.Internal
     (
       mkInvalidRecvArgError
-#if !defined(mingw32_HOST_OS)
-    , c_writev
-    , c_sendmsg
-#endif
     ) where
 
 import System.IO.Error (ioeSetErrorString, mkIOError)
 
-#if !defined(mingw32_HOST_OS)
-import Foreign.C.Types (CInt(..))
-import System.Posix.Types (CSsize(..))
-import Foreign.Ptr (Ptr)
-
-import Network.Socket.ByteString.IOVec (IOVec)
-import Network.Socket.ByteString.MsgHdr (MsgHdr)
-#endif
-
 import GHC.IO.Exception (IOErrorType(..))
 
 mkInvalidRecvArgError :: String -> IOError
 mkInvalidRecvArgError loc = ioeSetErrorString (mkIOError
                                     InvalidArgument
                                     loc Nothing Nothing) "non-positive length"
-
-#if !defined(mingw32_HOST_OS)
-foreign import ccall unsafe "writev"
-  c_writev :: CInt -> Ptr IOVec -> CInt -> IO CSsize
-
-foreign import ccall unsafe "sendmsg"
-  c_sendmsg :: CInt -> Ptr MsgHdr -> CInt -> IO CSsize
-#endif
diff --git a/Network/Socket/ByteString/Lazy.hs b/Network/Socket/ByteString/Lazy.hs
index e586943..01fd253 100644
--- a/Network/Socket/ByteString/Lazy.hs
+++ b/Network/Socket/ByteString/Lazy.hs
@@ -43,11 +43,7 @@ import System.IO.Unsafe (unsafeInterleaveIO)
 import qualified Data.ByteString as S
 import qualified Network.Socket.ByteString as N
 
-#if defined(mingw32_HOST_OS)
 import Network.Socket.ByteString.Lazy.Windows (send, sendAll)
-#else
-import Network.Socket.ByteString.Lazy.Posix (send, sendAll)
-#endif
 
 -- -----------------------------------------------------------------------------
 -- Receiving
diff --git a/Network/Socket/Internal.hsc b/Network/Socket/Internal.hs
similarity index 95%
rename from Network/Socket/Internal.hsc
rename to Network/Socket/Internal.hs
index 1372b25..43be9db 100644
--- a/Network/Socket/Internal.hsc
+++ b/Network/Socket/Internal.hs
@@ -32,12 +32,12 @@ module Network.Socket.Internal
     , PortNumber(..)
     , SockAddr(..)
 
-    , peekSockAddr
-    , pokeSockAddr
-    , sizeOfSockAddr
-    , sizeOfSockAddrByFamily
+    -- , peekSockAddr
+    -- , pokeSockAddr
+    -- , sizeOfSockAddr
+    -- , sizeOfSockAddrByFamily
     , withSockAddr
-    , withNewSockAddr
+    -- , withNewSockAddr
 
     -- * Protocol families
     , Family(..)
@@ -222,19 +222,13 @@ throwSocketErrorCode loc errno =
 -- @EWOULDBLOCK@ or similar, wait for the socket to be read-ready,
 -- and try again.
 throwSocketErrorWaitRead :: (Eq a, Num a) => Socket -> String -> IO a -> IO a
-throwSocketErrorWaitRead sock name io =
-    throwSocketErrorIfMinus1RetryMayBlock name
-        (threadWaitRead $ fromIntegral $ sockFd sock)
-        io
+throwSocketErrorWaitRead _sock _name io = io
 
 -- | Like 'throwSocketErrorIfMinus1Retry', but if the action fails with
 -- @EWOULDBLOCK@ or similar, wait for the socket to be write-ready,
 -- and try again.
 throwSocketErrorWaitWrite :: (Eq a, Num a) => Socket -> String -> IO a -> IO a
-throwSocketErrorWaitWrite sock name io =
-    throwSocketErrorIfMinus1RetryMayBlock name
-        (threadWaitWrite $ fromIntegral $ sockFd sock)
-        io
+throwSocketErrorWaitWrite _sock _name io = io
 
 -- ---------------------------------------------------------------------------
 -- WinSock support
diff --git a/Network/Socket/Types.hsc b/Network/Socket/Types.hs
similarity index 73%
rename from Network/Socket/Types.hsc
rename to Network/Socket/Types.hs
index bed07d1..4fc6f89 100644
--- a/Network/Socket/Types.hsc
+++ b/Network/Socket/Types.hs
@@ -33,6 +33,8 @@ module Network.Socket.Types
     -- * Socket addresses
     , SockAddr(..)
     , isSupportedSockAddr
+    , newSockAddr
+    , withSockAddr
     , HostAddress
     , hostAddressToTuple
     , tupleToHostAddress
@@ -43,12 +45,16 @@ module Network.Socket.Types
     , FlowInfo
     , ScopeID
 #endif
-    , peekSockAddr
-    , pokeSockAddr
-    , sizeOfSockAddr
-    , sizeOfSockAddrByFamily
-    , withSockAddr
-    , withNewSockAddr
+    , SocketAddress
+    , InetSocketAddress
+    , InetAddress
+    , InetAddressArray
+    , Inet4Address
+    , Inet6Address
+    , getByAddress
+    , mkInetSocketAddress
+    , inetAddrInt
+    , toJByteArray
 
     -- * Unsorted
     , ProtocolNumber
@@ -67,10 +73,11 @@ import Data.Typeable
 import Data.Word
 import Data.Int
 import Foreign.C
-import Foreign.Marshal.Alloc
-import Foreign.Marshal.Array
 import Foreign.Ptr
 import Foreign.Storable
+import System.Posix.Types (Channel)
+
+import Java
 
 -- | Represents a socket.  The fields are, respectively:
 --
@@ -85,14 +92,14 @@ import Foreign.Storable
 --   in non-blocking mode. See 'Network.Socket.setNonBlockIfNeeded'.
 data Socket
   = MkSocket
-            CInt                 -- File Descriptor
+            Channel              -- File Descriptor
             Family
             SocketType
             ProtocolNumber       -- Protocol Number
             (MVar SocketStatus)  -- Status Flag
   deriving Typeable
 
-sockFd :: Socket -> CInt
+sockFd :: Socket -> Channel
 sockFd       (MkSocket n _ _ _ _) = n
 
 sockFamily :: Socket -> Family
@@ -112,7 +119,12 @@ instance Eq Socket where
 
 instance Show Socket where
   showsPrec _n (MkSocket fd _ _ _ _) =
+#if ((ETA_VERSION == 9) && (ETA_BUILD_NUMBER >= 2)) || (ETA_VERSION > 9)
         showString "<socket: " . shows fd . showString ">"
+#else
+        showString "<socket" . showString ">"
+#endif
+
 
 type ProtocolNumber = CInt
 
@@ -124,12 +136,12 @@ type ProtocolNumber = CInt
 data SocketStatus
   -- Returned Status    Function called
   = NotConnected        -- ^ Newly created, unconnected socket
-  | Bound               -- ^ Bound, via 'bind'
+  | Bound SockAddr      -- ^ Bound, via 'bind'
   | Listening           -- ^ Listening, via 'listen'
   | Connected           -- ^ Connected or accepted, via 'connect' or 'accept'
   | ConvertedToHandle   -- ^ Is now a 'Handle' (via 'socketToHandle'), don't touch
   | Closed              -- ^ Closed was closed by 'close'
-    deriving (Eq, Show, Typeable)
+    deriving (Eq, Typeable)
 
 -----------------------------------------------------------------------------
 -- Socket types
@@ -159,6 +171,7 @@ data SocketType
         | Raw -- ^ SOCK_RAW
         | RDM -- ^ SOCK_RDM
         | SeqPacket -- ^ SOCK_SEQPACKET
+        | ServerSocket SocketType -- ^ ServerSocket
         deriving (Eq, Ord, Read, Show, Typeable)
 
 -- | Does the SOCK_ constant corresponding to the given SocketType exist on
@@ -171,23 +184,11 @@ packSocketType' :: SocketType -> Maybe CInt
 packSocketType' stype = case Just stype of
     -- the Just above is to disable GHC's overlapping pattern
     -- detection: see comments for packSocketOption
-    Just NoSocketType -> Just 0
-#ifdef SOCK_STREAM
-    Just Stream -> Just #const SOCK_STREAM
-#endif
-#ifdef SOCK_DGRAM
-    Just Datagram -> Just #const SOCK_DGRAM
-#endif
-#ifdef SOCK_RAW
-    Just Raw -> Just #const SOCK_RAW
-#endif
-#ifdef SOCK_RDM
-    Just RDM -> Just #const SOCK_RDM
-#endif
-#ifdef SOCK_SEQPACKET
-    Just SeqPacket -> Just #const SOCK_SEQPACKET
-#endif
-    _ -> Nothing
+    Just NoSocketType     -> Just 0
+    Just Stream           -> Just 1
+    Just Datagram         -> Just 2
+    Just (ServerSocket _) -> Just 3
+    _                     -> Nothing
 
 packSocketType :: SocketType -> CInt
 packSocketType stype = fromMaybe (error errMsg) (packSocketType' stype)
@@ -208,10 +209,13 @@ unpackSocketType:: CInt -> Maybe SocketType
 unpackSocketType t = case t of
         0 -> Just NoSocketType
 #ifdef SOCK_STREAM
-        (#const SOCK_STREAM) -> Just Stream
+        1 -> Just Stream
 #endif
 #ifdef SOCK_DGRAM
-        (#const SOCK_DGRAM) -> Just Datagram
+        2 -> Just Datagram
+#endif
+#ifdef SOCK_STREAM
+        3 -> Just (ServerSocket Stream)
 #endif
 #ifdef SOCK_RAW
         (#const SOCK_RAW) -> Just Raw
@@ -324,15 +328,15 @@ packFamily' :: Family -> Maybe CInt
 packFamily' f = case Just f of
     -- the Just above is to disable GHC's overlapping pattern
     -- detection: see comments for packSocketOption
-    Just AF_UNSPEC -> Just #const AF_UNSPEC
+    Just AF_UNSPEC -> Just 0
 #ifdef AF_UNIX
     Just AF_UNIX -> Just #const AF_UNIX
 #endif
-#ifdef AF_INET
-    Just AF_INET -> Just #const AF_INET
+#ifdef DEF_AF_INET
+    Just AF_INET -> Just 1
 #endif
-#ifdef AF_INET6
-    Just AF_INET6 -> Just #const AF_INET6
+#ifdef DEF_AF_INET6
+    Just AF_INET6 -> Just 2
 #endif
 #ifdef AF_IMPLINK
     Just AF_IMPLINK -> Just #const AF_IMPLINK
@@ -526,15 +530,15 @@ packFamily' f = case Just f of
 
 unpackFamily :: CInt -> Family
 unpackFamily f = case f of
-        (#const AF_UNSPEC) -> AF_UNSPEC
+        0 -> AF_UNSPEC
 #ifdef AF_UNIX
         (#const AF_UNIX) -> AF_UNIX
 #endif
-#ifdef AF_INET
-        (#const AF_INET) -> AF_INET
+#ifdef DEF_AF_INET
+        1 -> AF_INET
 #endif
-#ifdef AF_INET6
-        (#const AF_INET6) -> AF_INET6
+#ifdef DEF_AF_INET6
+        2 -> AF_INET6
 #endif
 #ifdef AF_IMPLINK
         (#const AF_IMPLINK) -> AF_IMPLINK
@@ -754,15 +758,10 @@ instance Read PortNumber where
   readsPrec n = map (\(x,y) -> (intToPortNumber x, y)) . readsPrec n
 
 intToPortNumber :: Int -> PortNumber
-intToPortNumber v = PortNum (htons (fromIntegral v))
+intToPortNumber v = PortNum (fromIntegral v)
 
 portNumberToInt :: PortNumber -> Int
-portNumberToInt (PortNum po) = fromIntegral (ntohs po)
-
-foreign import CALLCONV unsafe "ntohs" ntohs :: Word16 -> Word16
-foreign import CALLCONV unsafe "htons" htons :: Word16 -> Word16
-foreign import CALLCONV unsafe "ntohl" ntohl :: Word32 -> Word32
-foreign import CALLCONV unsafe "htonl" htonl :: Word32 -> Word32
+portNumberToInt (PortNum po) = fromIntegral po
 
 instance Enum PortNumber where
     toEnum   = intToPortNumber
@@ -854,151 +853,35 @@ isSupportedSockAddr addr = case addr of
   _ -> False
 #endif
 
-#if defined(WITH_WINSOCK)
-type CSaFamily = (#type unsigned short)
-#elif defined(darwin_HOST_OS)
-type CSaFamily = (#type u_char)
-#else
-type CSaFamily = (#type sa_family_t)
-#endif
-
--- | Computes the storage requirements (in bytes) of the given
--- 'SockAddr'.  This function differs from 'Foreign.Storable.sizeOf'
--- in that the value of the argument /is/ used.
-sizeOfSockAddr :: SockAddr -> Int
-#if defined(DOMAIN_SOCKET_SUPPORT)
-sizeOfSockAddr (SockAddrUnix path) =
-    case path of
-        '\0':_ -> (#const sizeof(sa_family_t)) + length path
-        _      -> #const sizeof(struct sockaddr_un)
-#endif
-sizeOfSockAddr (SockAddrInet _ _) = #const sizeof(struct sockaddr_in)
-#if defined(IPV6_SOCKET_SUPPORT)
-sizeOfSockAddr (SockAddrInet6 _ _ _ _) = #const sizeof(struct sockaddr_in6)
-#endif
-#if defined(CAN_SOCKET_SUPPORT)
-sizeOfSockAddr (SockAddrCan _) = #const sizeof(struct sockaddr_can)
-#endif
-
--- | Computes the storage requirements (in bytes) required for a
--- 'SockAddr' with the given 'Family'.
-sizeOfSockAddrByFamily :: Family -> Int
-#if defined(DOMAIN_SOCKET_SUPPORT)
-sizeOfSockAddrByFamily AF_UNIX  = #const sizeof(struct sockaddr_un)
-#endif
-#if defined(IPV6_SOCKET_SUPPORT)
-sizeOfSockAddrByFamily AF_INET6 = #const sizeof(struct sockaddr_in6)
-#endif
-sizeOfSockAddrByFamily AF_INET  = #const sizeof(struct sockaddr_in)
-#if defined(CAN_SOCKET_SUPPORT)
-sizeOfSockAddrByFamily AF_CAN   = #const sizeof(struct sockaddr_can)
-#endif
-sizeOfSockAddrByFamily family = error $
-    "Network.Socket.Types.sizeOfSockAddrByFamily: address family '" ++
-    show family ++ "' not supported."
-
 -- | Use a 'SockAddr' with a function requiring a pointer to a
 -- 'SockAddr' and the length of that 'SockAddr'.
-withSockAddr :: SockAddr -> (Ptr SockAddr -> Int -> IO a) -> IO a
-withSockAddr addr f = do
-    let sz = sizeOfSockAddr addr
-    allocaBytes sz $ \p -> pokeSockAddr p addr >> f (castPtr p) sz
-
--- | Create a new 'SockAddr' for use with a function requiring a
--- pointer to a 'SockAddr' and the length of that 'SockAddr'.
-withNewSockAddr :: Family -> (Ptr SockAddr -> Int -> IO a) -> IO a
-withNewSockAddr family f = do
-    let sz = sizeOfSockAddrByFamily family
-    allocaBytes sz $ \ptr -> f ptr sz
-
--- We can't write an instance of 'Storable' for 'SockAddr' because
--- @sockaddr@ is a sum type of variable size but
--- 'Foreign.Storable.sizeOf' is required to be constant.
-
--- Note that on Darwin, the sockaddr structure must be zeroed before
--- use.
-
--- | Write the given 'SockAddr' to the given memory location.
-pokeSockAddr :: Ptr a -> SockAddr -> IO ()
-#if defined(DOMAIN_SOCKET_SUPPORT)
-pokeSockAddr p (SockAddrUnix path) = do
-#if defined(darwin_HOST_OS)
-    zeroMemory p (#const sizeof(struct sockaddr_un))
-#else
-    case path of
-      ('\0':_) -> zeroMemory p (#const sizeof(struct sockaddr_un))
-      _        -> return ()
-#endif
-#if defined(HAVE_STRUCT_SOCKADDR_SA_LEN)
-    (#poke struct sockaddr_un, sun_len) p ((#const sizeof(struct sockaddr_un)) :: Word8)
-#endif
-    (#poke struct sockaddr_un, sun_family) p ((#const AF_UNIX) :: CSaFamily)
-    let pathC = map castCharToCChar path
-        poker = case path of ('\0':_) -> pokeArray; _ -> pokeArray0 0
-    poker ((#ptr struct sockaddr_un, sun_path) p) pathC
-#endif
-pokeSockAddr p (SockAddrInet (PortNum port) addr) = do
-#if defined(darwin_HOST_OS)
-    zeroMemory p (#const sizeof(struct sockaddr_in))
-#endif
-#if defined(HAVE_STRUCT_SOCKADDR_SA_LEN)
-    (#poke struct sockaddr_in, sin_len) p ((#const sizeof(struct sockaddr_in)) :: Word8)
-#endif
-    (#poke struct sockaddr_in, sin_family) p ((#const AF_INET) :: CSaFamily)
-    (#poke struct sockaddr_in, sin_port) p port
-    (#poke struct sockaddr_in, sin_addr) p addr
-#if defined(IPV6_SOCKET_SUPPORT)
-pokeSockAddr p (SockAddrInet6 (PortNum port) flow addr scope) = do
-#if defined(darwin_HOST_OS)
-    zeroMemory p (#const sizeof(struct sockaddr_in6))
-#endif
-#if defined(HAVE_STRUCT_SOCKADDR_SA_LEN)
-    (#poke struct sockaddr_in6, sin6_len) p ((#const sizeof(struct sockaddr_in6)) :: Word8)
-#endif
-    (#poke struct sockaddr_in6, sin6_family) p ((#const AF_INET6) :: CSaFamily)
-    (#poke struct sockaddr_in6, sin6_port) p port
-    (#poke struct sockaddr_in6, sin6_flowinfo) p flow
-    (#poke struct sockaddr_in6, sin6_addr) p (In6Addr addr)
-    (#poke struct sockaddr_in6, sin6_scope_id) p scope
-#endif
-#if defined(CAN_SOCKET_SUPPORT)
-pokeSockAddr p (SockAddrCan ifIndex) = do
-#if defined(darwin_HOST_OS)
-    zeroMemory p (#const sizeof(struct sockaddr_can))
-#endif
-    (#poke struct sockaddr_can, can_ifindex) p ifIndex
-#endif
+newSockAddr :: Channel -> IO SockAddr
+newSockAddr ch = do
+  sock <- getSockAddr ch
+  let inet = inetAddrInt (sockInetAddress sock)
+      port = sockPort sock
+  return $ SockAddrInet (fromIntegral port) inet
 
--- | Read a 'SockAddr' from the given memory location.
-peekSockAddr :: Ptr SockAddr -> IO SockAddr
-peekSockAddr p = do
-  family <- (#peek struct sockaddr, sa_family) p
-  case family :: CSaFamily of
-#if defined(DOMAIN_SOCKET_SUPPORT)
-    (#const AF_UNIX) -> do
-        str <- peekCString ((#ptr struct sockaddr_un, sun_path) p)
-        return (SockAddrUnix str)
-#endif
-    (#const AF_INET) -> do
-        addr <- (#peek struct sockaddr_in, sin_addr) p
-        port <- (#peek struct sockaddr_in, sin_port) p
-        return (SockAddrInet (PortNum port) addr)
-#if defined(IPV6_SOCKET_SUPPORT)
-    (#const AF_INET6) -> do
-        port <- (#peek struct sockaddr_in6, sin6_port) p
-        flow <- (#peek struct sockaddr_in6, sin6_flowinfo) p
-        In6Addr addr <- (#peek struct sockaddr_in6, sin6_addr) p
-        scope <- (#peek struct sockaddr_in6, sin6_scope_id) p
-        return (SockAddrInet6 (PortNum port) flow addr scope)
-#endif
-#if defined(CAN_SOCKET_SUPPORT)
-    (#const AF_CAN) -> do
-        ifidx <- (#peek struct sockaddr_can, can_ifindex) p
-        return (SockAddrCan ifidx)
-#endif
-    _ -> ioError $ userError $
-      "Network.Socket.Types.peekSockAddr: address family '" ++
-      show family ++ "' not supported."
+-- | Use a 'SockAddr' with a function requiring a pointer to a
+-- 'SockAddr' and the length of that 'SockAddr'.
+withSockAddr :: SockAddr -> (SocketAddress -> IO a) -> IO a
+withSockAddr addr f = case addr of
+  SockAddrInet port host ->
+    f $ superCast $ mkInetSocketAddress
+      (getByAddress . toJByteArray $ padWord8s 4 host)
+      (fromIntegral port)
+  SockAddrInet6 port _ (w1, w2, w3, w4) _ ->
+    f $ superCast $ mkInetSocketAddress
+      (getByAddress . toJByteArray $ concatMap (padWord8s 4) [w1, w2, w3, w4])
+      (fromIntegral port)
+  _ -> error "Network.Socket.Types.withSockAddr: Invalid socket address type."
+  where toWord8s :: (Bits a, Integral a) => a -> [Word8]
+        toWord8s 0 = []
+        toWord8s n = fromIntegral (n .&. 255) : toWord8s (n `shiftR` 8)
+
+        padWord8s :: (Bits a, Integral a) => Int -> a -> [Word8]
+        padWord8s n a = replicate (abs (n - length word8s)) 0 ++ word8s
+          where word8s = reverse (toWord8s a)
 
 ------------------------------------------------------------------------
 
@@ -1016,7 +899,7 @@ type HostAddress = Word32
 -- regardless of host endianness.
 hostAddressToTuple :: HostAddress -> (Word8, Word8, Word8, Word8)
 hostAddressToTuple ha' =
-    let ha = htonl ha'
+    let ha = ha'
         byte i = fromIntegral (ha `shiftR` i) :: Word8
     in (byte 24, byte 16, byte 8, byte 0)
 
@@ -1024,7 +907,7 @@ hostAddressToTuple ha' =
 tupleToHostAddress :: (Word8, Word8, Word8, Word8) -> HostAddress
 tupleToHostAddress (b3, b2, b1, b0) =
     let x `sl` i = fromIntegral x `shiftL` i :: Word32
-    in ntohl $ (b3 `sl` 24) .|. (b2 `sl` 16) .|. (b1 `sl` 8) .|. (b0 `sl` 0)
+    in (b3 `sl` 24) .|. (b2 `sl` 16) .|. (b1 `sl` 8) .|. (b0 `sl` 0)
 
 #if defined(IPV6_SOCKET_SUPPORT)
 -- | Independent of endianness. For example @::1@ is stored as @(0, 0, 0, 1)@.
@@ -1047,65 +930,72 @@ tupleToHostAddress6 (w7, w6, w5, w4, w3, w2, w1, w0) =
     let add :: Word16 -> Word16 -> Word32
         high `add` low = (fromIntegral high `shiftL` 16) .|. (fromIntegral low)
     in (w7 `add` w6, w5 `add` w4, w3 `add` w2, w1 `add` w0)
-
--- The peek32 and poke32 functions work around the fact that the RFCs
--- don't require 32-bit-wide address fields to be present.  We can
--- only portably rely on an 8-bit field, s6_addr.
-
-s6_addr_offset :: Int
-s6_addr_offset = (#offset struct in6_addr, s6_addr)
-
-peek32 :: Ptr a -> Int -> IO Word32
-peek32 p i0 = do
-    let i' = i0 * 4
-        peekByte n = peekByteOff p (s6_addr_offset + i' + n) :: IO Word8
-        a `sl` i = fromIntegral a `shiftL` i
-    a0 <- peekByte 0
-    a1 <- peekByte 1
-    a2 <- peekByte 2
-    a3 <- peekByte 3
-    return ((a0 `sl` 24) .|. (a1 `sl` 16) .|. (a2 `sl` 8) .|. (a3 `sl` 0))
-
-poke32 :: Ptr a -> Int -> Word32 -> IO ()
-poke32 p i0 a = do
-    let i' = i0 * 4
-        pokeByte n = pokeByteOff p (s6_addr_offset + i' + n)
-        x `sr` i = fromIntegral (x `shiftR` i) :: Word8
-    pokeByte 0 (a `sr` 24)
-    pokeByte 1 (a `sr` 16)
-    pokeByte 2 (a `sr`  8)
-    pokeByte 3 (a `sr`  0)
-
--- | Private newtype proxy for the Storable instance. To avoid orphan instances.
-newtype In6Addr = In6Addr HostAddress6
-
-#if __GLASGOW_HASKELL__ < 800
-#let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
-#endif
-
-instance Storable In6Addr where
-    sizeOf _    = #const sizeof(struct in6_addr)
-    alignment _ = #alignment struct in6_addr
-
-    peek p = do
-        a <- peek32 p 0
-        b <- peek32 p 1
-        c <- peek32 p 2
-        d <- peek32 p 3
-        return $ In6Addr (a, b, c, d)
-
-    poke p (In6Addr (a, b, c, d)) = do
-        poke32 p 0 a
-        poke32 p 1 b
-        poke32 p 2 c
-        poke32 p 3 d
 #endif
 
-------------------------------------------------------------------------
--- Helper functions
+-- ------------------------------------------------------------------------
+-- -- Helper functions
+
 
-foreign import ccall unsafe "string.h" memset :: Ptr a -> CInt -> CSize -> IO ()
+foreign import java unsafe "@static eta.base.Utils.c_memset" memset
+  :: Ptr a -> CInt -> CSize -> IO (Ptr a)
 
 -- | Zero a structure.
 zeroMemory :: Ptr a -> CSize -> IO ()
-zeroMemory dest nbytes = memset dest 0 (fromIntegral nbytes)
+zeroMemory dest nbytes = memset dest 0 (fromIntegral nbytes) >> return ()
+
+data {-# CLASS "java.net.SocketAddress" #-} SocketAddress =
+  SA (Object# SocketAddress)
+  deriving Class
+
+type instance Inherits SocketAddress = '[Object]
+
+data {-# CLASS "java.net.InetSocketAddress" #-} InetSocketAddress =
+  ISA (Object# InetSocketAddress)
+  deriving Class
+
+type instance Inherits InetSocketAddress = '[SocketAddress]
+
+data {-# CLASS "java.net.InetAddress" #-} InetAddress =
+  IA (Object# InetAddress)
+  deriving Class
+
+type instance Inherits InetAddress = '[Object]
+
+data {-# CLASS "java.net.InetAddress[]" #-} InetAddressArray =
+  IArr (Object# InetAddressArray)
+  deriving Class
+
+instance JArray InetAddress InetAddressArray
+
+data {-# CLASS "java.net.Inet4Address" #-} Inet4Address =
+  I4A (Object# Inet4Address)
+  deriving Class
+
+type instance Inherits Inet4Address = '[InetAddress]
+
+data {-# CLASS "java.net.Inet6Address" #-} Inet6Address =
+  I6A (Object# Inet6Address)
+  deriving Class
+
+type instance Inherits Inet6Address = '[InetAddress]
+
+foreign import java unsafe "@static java.net.InetAddress.getByAddress" getByAddress :: JByteArray -> InetAddress
+
+foreign import java unsafe "@new" mkInetSocketAddress
+  :: InetAddress -> Int -> InetSocketAddress
+
+foreign import java unsafe "@static eta.network.Utils.getSockAddr" getSockAddr
+  :: Channel -> IO InetSocketAddress
+
+foreign import java unsafe "getAddress" sockInetAddress
+  :: InetSocketAddress -> InetAddress
+
+foreign import CALLCONV unsafe "getPort" sockPort :: InetSocketAddress -> Int
+
+toJByteArray :: [Word8] -> JByteArray
+toJByteArray word8s = toJava bytes
+  where bytes = map fromIntegral word8s :: [Byte]
+
+foreign import CALLCONV unsafe "@static eta.network.Utils.inetAddrInt"
+  inetAddrInt :: InetAddress -> Word32
+
diff --git a/include/HsNet.h b/include/HsNet.h
index 858ce4e..c172e11 100644
--- a/include/HsNet.h
+++ b/include/HsNet.h
@@ -7,182 +7,187 @@
 #ifndef HSNET_H
 #define HSNET_H
 
-#include "HsNetworkConfig.h"
-
-#ifdef NEED_WINVER
-# define WINVER 0x0501
-#endif
-
-/* ultra-evil... */
-#undef PACKAGE_BUGREPORT
-#undef PACKAGE_NAME
-#undef PACKAGE_STRING
-#undef PACKAGE_TARNAME
-#undef PACKAGE_VERSION
-
-#ifndef INLINE
-# if defined(_MSC_VER)
-#  define INLINE extern __inline
-# elif defined(__GNUC_GNU_INLINE__)
-#  define INLINE extern inline
-# else
-#  define INLINE inline
-# endif
-#endif
-
-#ifdef HAVE_GETADDRINFO
-# define IPV6_SOCKET_SUPPORT 1
-#else
-# undef IPV6_SOCKET_SUPPORT
-#endif
-
-#if defined(HAVE_WINSOCK2_H)
-#include <winsock2.h>
-# ifdef HAVE_WS2TCPIP_H
-#  include <ws2tcpip.h>
-// fix for MingW not defining IPV6_V6ONLY
-#  define IPV6_V6ONLY 27
-# endif
-
-extern int   initWinSock ();
-extern const char* getWSErrorDescr(int err);
-extern void* newAcceptParams(int sock,
-			     int sz,
-			     void* sockaddr);
-extern int   acceptNewSock(void* d);
-extern int   acceptDoProc(void* param);
-
-#else
-
-#ifdef HAVE_LIMITS_H
-# include <limits.h>
-#endif
-#ifdef HAVE_STDLIB_H
-# include <stdlib.h>
-#endif
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#ifdef HAVE_SYS_TYPES_H
-# include <sys/types.h>
-#endif
-#ifdef HAVE_FCNTL_H
-# include <fcntl.h>
-#endif
-#ifdef HAVE_SYS_UIO_H
-# include <sys/uio.h>
-#endif
-#ifdef HAVE_SYS_SOCKET_H
-# include <sys/socket.h>
-#endif
-#ifdef HAVE_LINUX_TCP_H
-# include <linux/tcp.h>
-#elif HAVE_NETINET_TCP_H
-# include <netinet/tcp.h>
-#endif
-#ifdef HAVE_NETINET_IN_H
-# include <netinet/in.h>
-#endif
-#ifdef HAVE_SYS_UN_H
-# include <sys/un.h>
-#endif
-#ifdef HAVE_ARPA_INET_H
-# include <arpa/inet.h>
-#endif
-#ifdef HAVE_NETDB_H
-#include <netdb.h>
-#endif
-#ifdef HAVE_LINUX_CAN_H
-# include <linux/can.h>
-# define CAN_SOCKET_SUPPORT 1
-#endif
-#ifdef HAVE_NET_IF
-# include <net/if.h>
-#endif
-
-#ifdef HAVE_BSD_SENDFILE
-#include <sys/uio.h>
-#endif
-#ifdef HAVE_LINUX_SENDFILE
-#if !defined(__USE_FILE_OFFSET64)
-#include <sys/sendfile.h>
-#endif
-#endif
-
-extern int
-sendFd(int sock, int outfd);
-
-extern int
-recvFd(int sock);
-
-#endif /* HAVE_WINSOCK2_H */
-
-INLINE char *
-hsnet_inet_ntoa(
-#if defined(HAVE_WINSOCK2_H)
-             u_long addr
-#elif defined(HAVE_IN_ADDR_T)
-             in_addr_t addr
-#elif defined(HAVE_INTTYPES_H)
-             u_int32_t addr
-#else
-             unsigned long addr
-#endif
-	    )
-{
-    struct in_addr a;
-    a.s_addr = addr;
-    return inet_ntoa(a);
-}
-
-#ifdef HAVE_GETADDRINFO
-INLINE int
-hsnet_getnameinfo(const struct sockaddr* a,socklen_t b, char* c,
-# if defined(HAVE_WINSOCK2_H)
-                  DWORD d, char* e, DWORD f, int g)
-# else
-                  socklen_t d, char* e, socklen_t f, int g)
-# endif
-{
-  return getnameinfo(a,b,c,d,e,f,g);
-}
-
-INLINE int
-hsnet_getaddrinfo(const char *hostname, const char *servname,
-		  const struct addrinfo *hints, struct addrinfo **res)
-{
-    return getaddrinfo(hostname, servname, hints, res);
-}
-
-INLINE void
-hsnet_freeaddrinfo(struct addrinfo *ai)
-{
-    freeaddrinfo(ai);
-}
-#endif
-
-#if defined(HAVE_WINSOCK2_H)
-# define WITH_WINSOCK  1
-#endif
-
-#if !defined(mingw32_HOST_OS) && !defined(_WIN32)
-# define DOMAIN_SOCKET_SUPPORT 1
-#endif
-
-#if !defined(CALLCONV)
-# if defined(WITH_WINSOCK)
-#  define CALLCONV stdcall
-# else
-#  define CALLCONV ccall
-# endif
-#endif
-
-#if !defined(IOV_MAX)
-# define IOV_MAX 1024
-#endif
-
-#if !defined(SOCK_NONBLOCK) // Missing define in Bionic libc (Android)
-# define SOCK_NONBLOCK O_NONBLOCK
-#endif
+#define IPV6_SOCKET_SUPPORT 1
+#define SOCK_STREAM         1
+#define SOCK_DGRAM          1
+#define DEF_AF_INET         1
+#define DEF_AF_INET6        1
+#define CALLCONV            java
+
+/* #ifdef NEED_WINVER */
+/* # define WINVER 0x0501 */
+/* #endif */
+
+/* /\* ultra-evil... *\/ */
+/* #undef PACKAGE_BUGREPORT */
+/* #undef PACKAGE_NAME */
+/* #undef PACKAGE_STRING */
+/* #undef PACKAGE_TARNAME */
+/* #undef PACKAGE_VERSION */
+
+/* #ifndef INLINE */
+/* # if defined(_MSC_VER) */
+/* #  define INLINE extern __inline */
+/* # elif defined(__GNUC_GNU_INLINE__) */
+/* #  define INLINE extern inline */
+/* # else */
+/* #  define INLINE inline */
+/* # endif */
+/* #endif */
+
+/* #ifdef HAVE_GETADDRINFO */
+/* # define IPV6_SOCKET_SUPPORT 1 */
+/* #else */
+/* # undef IPV6_SOCKET_SUPPORT */
+/* #endif */
+
+/* #if defined(HAVE_WINSOCK2_H) */
+/* #include <winsock2.h> */
+/* # ifdef HAVE_WS2TCPIP_H */
+/* #  include <ws2tcpip.h> */
+/* // fix for MingW not defining IPV6_V6ONLY */
+/* #  define IPV6_V6ONLY 27 */
+/* # endif */
+
+/* extern int   initWinSock (); */
+/* extern const char* getWSErrorDescr(int err); */
+/* extern void* newAcceptParams(int sock, */
+/* 			     int sz, */
+/* 			     void* sockaddr); */
+/* extern int   acceptNewSock(void* d); */
+/* extern int   acceptDoProc(void* param); */
+
+/* #else */
+
+/* #ifdef HAVE_LIMITS_H */
+/* # include <limits.h> */
+/* #endif */
+/* #ifdef HAVE_STDLIB_H */
+/* # include <stdlib.h> */
+/* #endif */
+/* #ifdef HAVE_UNISTD_H */
+/* #include <unistd.h> */
+/* #endif */
+/* #ifdef HAVE_SYS_TYPES_H */
+/* # include <sys/types.h> */
+/* #endif */
+/* #ifdef HAVE_FCNTL_H */
+/* # include <fcntl.h> */
+/* #endif */
+/* #ifdef HAVE_SYS_UIO_H */
+/* # include <sys/uio.h> */
+/* #endif */
+/* #ifdef HAVE_SYS_SOCKET_H */
+/* # include <sys/socket.h> */
+/* #endif */
+/* #ifdef HAVE_LINUX_TCP_H */
+/* # include <linux/tcp.h> */
+/* #elif HAVE_NETINET_TCP_H */
+/* # include <netinet/tcp.h> */
+/* #endif */
+/* #ifdef HAVE_NETINET_IN_H */
+/* # include <netinet/in.h> */
+/* #endif */
+/* #ifdef HAVE_SYS_UN_H */
+/* # include <sys/un.h> */
+/* #endif */
+/* #ifdef HAVE_ARPA_INET_H */
+/* # include <arpa/inet.h> */
+/* #endif */
+/* #ifdef HAVE_NETDB_H */
+/* #include <netdb.h> */
+/* #endif */
+/* #ifdef HAVE_LINUX_CAN_H */
+/* # include <linux/can.h> */
+/* # define CAN_SOCKET_SUPPORT 1 */
+/* #endif */
+/* #ifdef HAVE_NET_IF */
+/* # include <net/if.h> */
+/* #endif */
+
+/* #ifdef HAVE_BSD_SENDFILE */
+/* #include <sys/uio.h> */
+/* #endif */
+/* #ifdef HAVE_LINUX_SENDFILE */
+/* #if !defined(__USE_FILE_OFFSET64) */
+/* #include <sys/sendfile.h> */
+/* #endif */
+/* #endif */
+
+/* extern int */
+/* sendFd(int sock, int outfd); */
+
+/* extern int */
+/* recvFd(int sock); */
+
+/* #endif /\* HAVE_WINSOCK2_H *\/ */
+
+/* INLINE char * */
+/* hsnet_inet_ntoa( */
+/* #if defined(HAVE_WINSOCK2_H) */
+/*              u_long addr */
+/* #elif defined(HAVE_IN_ADDR_T) */
+/*              in_addr_t addr */
+/* #elif defined(HAVE_INTTYPES_H) */
+/*              u_int32_t addr */
+/* #else */
+/*              unsigned long addr */
+/* #endif */
+/* 	    ) */
+/* { */
+/*     struct in_addr a; */
+/*     a.s_addr = addr; */
+/*     return inet_ntoa(a); */
+/* } */
+
+/* #ifdef HAVE_GETADDRINFO */
+/* INLINE int */
+/* hsnet_getnameinfo(const struct sockaddr* a,socklen_t b, char* c, */
+/* # if defined(HAVE_WINSOCK2_H) */
+/*                   DWORD d, char* e, DWORD f, int g) */
+/* # else */
+/*                   socklen_t d, char* e, socklen_t f, int g) */
+/* # endif */
+/* { */
+/*   return getnameinfo(a,b,c,d,e,f,g); */
+/* } */
+
+/* INLINE int */
+/* hsnet_getaddrinfo(const char *hostname, const char *servname, */
+/* 		  const struct addrinfo *hints, struct addrinfo **res) */
+/* { */
+/*     return getaddrinfo(hostname, servname, hints, res); */
+/* } */
+
+/* INLINE void */
+/* hsnet_freeaddrinfo(struct addrinfo *ai) */
+/* { */
+/*     freeaddrinfo(ai); */
+/* } */
+/* #endif */
+
+/* #if defined(HAVE_WINSOCK2_H) */
+/* # define WITH_WINSOCK  1 */
+/* #endif */
+
+/* #if !defined(mingw32_HOST_OS) && !defined(_WIN32) */
+/* # define DOMAIN_SOCKET_SUPPORT 1 */
+/* #endif */
+
+/* #if !defined(CALLCONV) */
+/* # if defined(WITH_WINSOCK) */
+/* #  define CALLCONV stdcall */
+/* # else */
+/* #  define CALLCONV ccall */
+/* # endif */
+/* #endif */
+
+/* #if !defined(IOV_MAX) */
+/* # define IOV_MAX 1024 */
+/* #endif */
+
+/* #if !defined(SOCK_NONBLOCK) // Missing define in Bionic libc (Android) */
+/* # define SOCK_NONBLOCK O_NONBLOCK */
+/* #endif */
 
 #endif /* HSNET_H */
diff --git a/include/HsNetworkConfig.h b/include/HsNetworkConfig.h
deleted file mode 100644
index 6dcef8f..0000000
--- a/include/HsNetworkConfig.h
+++ /dev/null
@@ -1,178 +0,0 @@
-/* include/HsNetworkConfig.h.  Generated from HsNetworkConfig.h.in by configure.  */
-/* include/HsNetworkConfig.h.in.  Generated from configure.ac by autoheader.  */
-
-/* Define to 1 if you have the `accept4' function. */
-#define HAVE_ACCEPT4 1
-
-/* Define to 1 if you have the <arpa/inet.h> header file. */
-#define HAVE_ARPA_INET_H 1
-
-/* Define to 1 if you have a BSDish sendfile(2) implementation. */
-/* #undef HAVE_BSD_SENDFILE */
-
-/* Define to 1 if you have the declaration of `AI_ADDRCONFIG', and to 0 if you
-   don't. */
-#define HAVE_DECL_AI_ADDRCONFIG 1
-
-/* Define to 1 if you have the declaration of `AI_ALL', and to 0 if you don't.
-   */
-#define HAVE_DECL_AI_ALL 1
-
-/* Define to 1 if you have the declaration of `AI_NUMERICSERV', and to 0 if
-   you don't. */
-#define HAVE_DECL_AI_NUMERICSERV 1
-
-/* Define to 1 if you have the declaration of `AI_V4MAPPED', and to 0 if you
-   don't. */
-#define HAVE_DECL_AI_V4MAPPED 1
-
-/* Define to 1 if you have the declaration of `IPPROTO_IP', and to 0 if you
-   don't. */
-#define HAVE_DECL_IPPROTO_IP 1
-
-/* Define to 1 if you have the declaration of `IPPROTO_IPV6', and to 0 if you
-   don't. */
-#define HAVE_DECL_IPPROTO_IPV6 1
-
-/* Define to 1 if you have the declaration of `IPPROTO_TCP', and to 0 if you
-   don't. */
-#define HAVE_DECL_IPPROTO_TCP 1
-
-/* Define to 1 if you have the declaration of `IPV6_V6ONLY', and to 0 if you
-   don't. */
-#define HAVE_DECL_IPV6_V6ONLY 1
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#define HAVE_FCNTL_H 1
-
-/* Define to 1 if you have the `gai_strerror' function. */
-#define HAVE_GAI_STRERROR 1
-
-/* Define to 1 if you have the `getaddrinfo' function. */
-#define HAVE_GETADDRINFO 1
-
-/* Define to 1 if you have the `gethostent' function. */
-#define HAVE_GETHOSTENT 1
-
-/* Define to 1 if you have getpeereid. */
-/* #undef HAVE_GETPEEREID */
-
-/* Define to 1 if you have the `if_nametoindex' function. */
-#define HAVE_IF_NAMETOINDEX 1
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#define HAVE_INTTYPES_H 1
-
-/* Define to 1 if in_addr_t is available. */
-#define HAVE_IN_ADDR_T 1
-
-/* Define to 1 if you have the `ws2_32' library (-lws2_32). */
-/* #undef HAVE_LIBWS2_32 */
-
-/* Define to 1 if you have the <limits.h> header file. */
-#define HAVE_LIMITS_H 1
-
-/* Define to 1 if you have the <linux/can.h> header file. */
-#define HAVE_LINUX_CAN_H 1
-
-/* Define to 1 if you have a Linux sendfile(2) implementation. */
-#define HAVE_LINUX_SENDFILE 1
-
-/* Define to 1 if you have the <linux/tcp.h> header file. */
-#define HAVE_LINUX_TCP_H 1
-
-/* Define to 1 if you have the <memory.h> header file. */
-#define HAVE_MEMORY_H 1
-
-/* Define to 1 if you have the <netdb.h> header file. */
-#define HAVE_NETDB_H 1
-
-/* Define to 1 if you have the <netinet/in.h> header file. */
-#define HAVE_NETINET_IN_H 1
-
-/* Define to 1 if you have the <netinet/tcp.h> header file. */
-#define HAVE_NETINET_TCP_H 1
-
-/* Define to 1 if you have the <net/if.h> header file. */
-#define HAVE_NET_IF_H 1
-
-/* Define to 1 if you have the `readlink' function. */
-#define HAVE_READLINK 1
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#define HAVE_STDINT_H 1
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#define HAVE_STDLIB_H 1
-
-/* Define to 1 if you have the <strings.h> header file. */
-#define HAVE_STRINGS_H 1
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if `msg_accrights' is a member of `struct msghdr'. */
-/* #undef HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS */
-
-/* Define to 1 if `msg_control' is a member of `struct msghdr'. */
-#define HAVE_STRUCT_MSGHDR_MSG_CONTROL 1
-
-/* Define to 1 if `sa_len' is a member of `struct sockaddr'. */
-/* #undef HAVE_STRUCT_SOCKADDR_SA_LEN */
-
-/* Define to 1 if you have both SO_PEERCRED and struct ucred. */
-#define HAVE_STRUCT_UCRED 1
-
-/* Define to 1 if you have the `symlink' function. */
-#define HAVE_SYMLINK 1
-
-/* Define to 1 if you have the <sys/socket.h> header file. */
-#define HAVE_SYS_SOCKET_H 1
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#define HAVE_SYS_STAT_H 1
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the <sys/uio.h> header file. */
-#define HAVE_SYS_UIO_H 1
-
-/* Define to 1 if you have the <sys/un.h> header file. */
-#define HAVE_SYS_UN_H 1
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#define HAVE_UNISTD_H 1
-
-/* Define to 1 if you have the <winsock2.h> header file. */
-/* #undef HAVE_WINSOCK2_H */
-
-/* Define to 1 if you have the <ws2tcpip.h> header file. */
-/* #undef HAVE_WS2TCPIP_H */
-
-/* Define to 1 if the `getaddrinfo' function needs WINVER set. */
-/* #undef NEED_WINVER_XP */
-
-/* Define to the address where bug reports for this package should be sent. */
-#define PACKAGE_BUGREPORT "libraries@haskell.org"
-
-/* Define to the full name of this package. */
-#define PACKAGE_NAME "Haskell network package"
-
-/* Define to the full name and version of this package. */
-#define PACKAGE_STRING "Haskell network package 2.6.3.1"
-
-/* Define to the one symbol short name of this package. */
-#define PACKAGE_TARNAME "network"
-
-/* Define to the home page for this package. */
-#define PACKAGE_URL ""
-
-/* Define to the version of this package. */
-#define PACKAGE_VERSION "2.6.3.1"
-
-/* Define to 1 if you have the ANSI C header files. */
-#define STDC_HEADERS 1
-
-/* Define to empty if `const' does not conform to ANSI C. */
-/* #undef const */
diff --git a/java/Utils.java b/java/Utils.java
new file mode 100644
index 0000000..9229860
--- /dev/null
+++ b/java/Utils.java
@@ -0,0 +1,193 @@
+package eta.network;
+
+import java.io.IOException;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Inet6Address;
+import java.net.SocketAddress;
+import java.net.SocketOption;
+import java.net.StandardSocketOptions;
+import java.net.UnknownHostException;
+import java.net.ProtocolFamily;
+import java.net.StandardProtocolFamily;
+
+import java.nio.ByteBuffer;
+import java.nio.channels.Channel;
+import java.nio.channels.DatagramChannel;
+import java.nio.channels.NetworkChannel;
+import java.nio.channels.ServerSocketChannel;
+import java.nio.channels.SelectableChannel;
+import java.nio.channels.SocketChannel;
+import java.nio.channels.ClosedChannelException;
+
+import eta.runtime.io.MemoryManager;
+
+public class Utils {
+    public static boolean isIPv6(InetAddress address) {
+        return (address instanceof Inet6Address);
+    }
+    public static byte[] fromWord32(int word32) {
+        return new byte[]{
+            (byte)(word32 >>> 24),
+            (byte)(word32 >>> 16),
+            (byte)(word32 >>> 8),
+            (byte)word32
+        };
+    }
+    public static String inet_ntoa(int bytes) throws UnknownHostException {
+        return InetAddress.getByAddress(fromWord32(bytes)).toString().substring(1);
+    }
+
+    public static String inet6_ntoa(int[] addr) {
+        String res="";
+        if (addr !=null) {
+            for (int i=0; i < addr.length; i++) {
+                res+=Integer.toHexString(addr[i]) +
+                    (i < addr.length-1?":":"");
+            }
+        }
+        return res;
+    }
+
+    public static int inetAddrInt(InetAddress address) {
+        int bOut = 0;
+        for (byte b: address.getAddress()) {
+            bOut = (((int) b) & 0xFF) | (bOut << 8);
+        }
+        return bOut;
+    }
+
+    public static String getNameInfo(byte[] address) throws UnknownHostException{
+        return InetAddress.getByAddress(address).getHostName();
+    }
+
+    public static int inet_addr(String address) {
+        try {
+            return inetAddrInt(InetAddress.getByName(address));
+        } catch (UnknownHostException e) {
+            return -1;
+        }
+    }
+
+    public static boolean isBlocking(Channel c) {
+        if (c instanceof SelectableChannel) {
+            SelectableChannel sc = (SelectableChannel) c;
+            return sc.isBlocking();
+        } else {
+            return true;
+        }
+    }
+
+    public static Channel socket(int family, int socketType, int protocol) throws IOException {
+        switch (socketType) {
+          case 1:
+              return SocketChannel.open();
+          case 2:
+              if (family != 0) {
+                  ProtocolFamily pf = (family == 1)?
+                      StandardProtocolFamily.INET : StandardProtocolFamily.INET6;
+                  return DatagramChannel.open(pf);
+              } else {
+                  return DatagramChannel.open();
+              }
+          case 3:
+              return ServerSocketChannel.open();
+        }
+        return null;
+    }
+
+    public static int bind(Channel c, SocketAddress address) throws IOException {
+        if ((c instanceof NetworkChannel) && !(c instanceof ServerSocketChannel)) {
+            ((NetworkChannel) c).bind(address);
+        }
+        return 0;
+    }
+
+    public static boolean connect(Channel c, SocketAddress address) throws IOException {
+        if (c instanceof SocketChannel) {
+            SocketChannel sc = (SocketChannel) c;
+            if (sc.isConnectionPending()) {
+                return sc.finishConnect();
+            } else {
+                return sc.connect(address);
+            }
+        }
+        return false;
+    }
+
+    public static int listen(Channel c, SocketAddress saddr, int backlog) throws IOException {
+        if (c instanceof ServerSocketChannel) {
+            ((ServerSocketChannel) c).bind(saddr, backlog);
+        }
+        return 0;
+    }
+
+    public static Channel accept(Channel c) throws IOException {
+        Thread.interrupted();
+        if (c instanceof ServerSocketChannel) {
+            return ((ServerSocketChannel) c).accept();
+        } else {
+            return null;
+        }
+    }
+
+    public static int shutdown(Channel c, int shutdownCode) throws IOException {
+        if (c instanceof SocketChannel) {
+            try {
+                SocketChannel sc = (SocketChannel) c;
+                switch (shutdownCode) {
+                    case 0:
+                        sc.shutdownInput();
+                        break;
+                    case 1:
+                        sc.shutdownOutput();
+                        break;
+                    case 2:
+                        sc.shutdownInput();
+                        sc.shutdownOutput();
+                        break;
+                }
+            } catch (ClosedChannelException e) {
+                /* It's OK if it's already closed.
+                   Just proceed as normal. */
+            }
+        }
+        return 0;
+    }
+
+    public static int sendto(Channel c, long ptr, int size, SocketAddress addr) throws IOException {
+        ByteBuffer src = MemoryManager.getBoundedBuffer(ptr);
+        src.limit(src.position() + size);
+        return ((DatagramChannel) c).send(src, addr);
+    }
+
+    public static int getsockopt(Channel c, SocketOption<Integer> option) throws IOException {
+        return ((NetworkChannel) c).getOption(option);
+    }
+
+    @SuppressWarnings("unchecked")
+    public static void setsockopt(Channel c, SocketOption option, int value) throws IOException {
+        if (option == StandardSocketOptions.SO_REUSEADDR
+            || option == StandardSocketOptions.SO_KEEPALIVE
+            || option == StandardSocketOptions.IP_MULTICAST_LOOP
+            || option == StandardSocketOptions.SO_BROADCAST
+            || option == StandardSocketOptions.TCP_NODELAY) {
+            ((NetworkChannel) c).setOption(option, Boolean.valueOf(value == 1));
+        } else {
+            ((NetworkChannel) c).setOption(option, Integer.valueOf(value));
+        }
+    }
+
+    public static String getHostByAddr(int hostAddr) throws UnknownHostException {
+        return InetAddress.getByAddress(fromWord32(hostAddr)).getHostName();
+    }
+
+    public static InetAddress[] getHostsByAddr(int hostAddr) throws UnknownHostException {
+        return InetAddress.getAllByName(InetAddress.getByAddress(fromWord32(hostAddr)).getHostName());
+    }
+
+    public static InetSocketAddress getSockAddr(Channel c) throws IOException {
+        return (InetSocketAddress) ((SocketChannel) c).getRemoteAddress();
+    }
+}
diff --git a/network.cabal b/network.cabal
index ede8fd2..0350a44 100644
--- a/network.cabal
+++ b/network.cabal
@@ -26,7 +26,7 @@ description:
   That is, get the module from either network < 2.6 or from
   network-uri >= 2.6.
 category:       Network
-build-type:     Configure
+build-type:     Simple
 cabal-version:  >=1.8
 extra-tmp-files:
   config.log config.status autom4te.cache network.buildinfo
@@ -53,32 +53,24 @@ library
     Network.Socket.Internal
   other-modules:
     Network.Socket.ByteString.Internal
+    Network.Socket.ByteString.Lazy.Windows
     Network.Socket.Types
 
-  if !os(windows)
-    other-modules:
-      Network.Socket.ByteString.IOVec
-      Network.Socket.ByteString.Lazy.Posix
-      Network.Socket.ByteString.MsgHdr
-  if os(windows)
-    other-modules:
-      Network.Socket.ByteString.Lazy.Windows
-
   build-depends:
     base >= 3 && < 5,
     bytestring < 0.11
 
-  if !os(windows)
-    build-depends:
-      unix >= 2
-
   extensions:
-    CPP, DeriveDataTypeable, ForeignFunctionInterface, TypeSynonymInstances
+    CPP, DeriveDataTypeable, ForeignFunctionInterface, TypeSynonymInstances,
+    MagicHash, TypeOperators, DataKinds, TypeFamilies, MultiParamTypeClasses
+
   include-dirs: include
   includes: HsNet.h
-  install-includes: HsNet.h HsNetworkConfig.h
-  c-sources: cbits/HsNet.c
+  if impl(eta >= 0.0.9.2)
+    java-sources: java/Utils.java
   ghc-options: -Wall -fwarn-tabs
+  if impl(eta < 0.7.1.3)
+     ghc-options: -optP--text
 
 test-suite simple
   hs-source-dirs: tests
-- 
2.18.0

